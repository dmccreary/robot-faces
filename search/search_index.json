{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Robot Faces This guide will help you learn how to draw fun faces on your robots. We use bright 128x64 OLED displays that cost about $20. We use simple MicroPython code so students can create their own personalized robot faces.","title":"Home"},{"location":"#welcome-to-robot-faces","text":"This guide will help you learn how to draw fun faces on your robots. We use bright 128x64 OLED displays that cost about $20. We use simple MicroPython code so students can create their own personalized robot faces.","title":"Welcome to Robot Faces"},{"location":"about/","text":"About The Robot Faces Book The book is designed to be a fun way to teach concepts in computational thinking. It was designed to use low-cost parts to keep robot kits as low as possible. Most classrooms can create projects for under $35 per robot if you purchase parts in a quantity of 10. Primary Goals Create hands-on lessons that are fun for students Teach fundamentals of computational thinking such as abstractions, functions and modularity Get students to think about how faces are used to communicate emotions","title":"About The Robot Faces Book"},{"location":"about/#about-the-robot-faces-book","text":"The book is designed to be a fun way to teach concepts in computational thinking. It was designed to use low-cost parts to keep robot kits as low as possible. Most classrooms can create projects for under $35 per robot if you purchase parts in a quantity of 10.","title":"About The Robot Faces Book"},{"location":"about/#primary-goals","text":"Create hands-on lessons that are fun for students Teach fundamentals of computational thinking such as abstractions, functions and modularity Get students to think about how faces are used to communicate emotions","title":"Primary Goals"},{"location":"contact/","text":"Contact Dan McCreary","title":"Contact"},{"location":"contact/#contact","text":"Dan McCreary","title":"Contact"},{"location":"getting-started/","text":"Getting Started with Robot Faces Here are the steps you can use to get started drawing your own robot faces. Step 1: Getting Hardware You can order the parts online or work with one of our programs that supply parts for classrooms. The minimal drawing kit contains: A Raspberry Pi Pico A mini solderless [Breadboard]../docs/parts-lists/#solderless-breadboard) An OLED display M-F jumper wires Step 2: Installing Software We use the \"Thonny\" editor to program our faces. To use it you will need to: Download and install Thonny Initialize the runtime by downloading the Pressing the Stop/Reset Drawing Your Fist Face You can now copy our \"simple-face.py\" program into your microcontroller into your Thonny program and press the green \"Run\" button. You will see the following on your display:","title":"Getting Started"},{"location":"getting-started/#getting-started-with-robot-faces","text":"Here are the steps you can use to get started drawing your own robot faces.","title":"Getting Started with Robot Faces"},{"location":"getting-started/#step-1-getting-hardware","text":"You can order the parts online or work with one of our programs that supply parts for classrooms. The minimal drawing kit contains: A Raspberry Pi Pico A mini solderless [Breadboard]../docs/parts-lists/#solderless-breadboard) An OLED display M-F jumper wires","title":"Step 1: Getting Hardware"},{"location":"getting-started/#step-2-installing-software","text":"We use the \"Thonny\" editor to program our faces. To use it you will need to: Download and install Thonny Initialize the runtime by downloading the Pressing the Stop/Reset","title":"Step 2: Installing Software"},{"location":"getting-started/#drawing-your-fist-face","text":"You can now copy our \"simple-face.py\" program into your microcontroller into your Thonny program and press the green \"Run\" button. You will see the following on your display:","title":"Drawing Your Fist Face"},{"location":"glossary/","text":"Robot Faces Glossary of Terms Blit Block transfer Ellipse RP2040","title":"Glossary"},{"location":"glossary/#robot-faces-glossary-of-terms","text":"","title":"Robot Faces Glossary of Terms"},{"location":"glossary/#blit","text":"Block transfer","title":"Blit"},{"location":"glossary/#ellipse","text":"","title":"Ellipse"},{"location":"glossary/#rp2040","text":"","title":"RP2040"},{"location":"parts-lists/","text":"Robot Faces Parts List Microcontrollers You can use any microcontroller that supports an SPI interface and has a MicroPython driver. Here are some of our favorites. Raspberry Pi Pico The Raspberry Pi Pico is a $4 microcontroller that supports SPI. This allows you to test your face drawing for under $25. Cytron Maker Pi RP2040 Displays 128X64 OLEDs We love the $20 128x64 OLED displays. These displays have fast SPI drivers that will update the display in around 2 milliseconds. Robot Chassis We use a standard \"Smart Car\" chassis to drive our cars. These parts can be purchased for around $5 each in quantity 10. Sensors This course is not intended to be a complete guide to sensors, but here are a few favorite sensors our students like to use. Momentary Push Buttons We use momentary push buttons that are ideal for changing the mode of a robot. They can be purchased for about 10 cents in quantity 10. Potentiometers These are ideal for allowing students to vary a parameter of a face such as the curvature or width of a smile. Rotary Encoders Solderless Breadboard We use $2 solderless mini breadboards to test our displays. ~","title":"Robot Faces Parts List"},{"location":"parts-lists/#robot-faces-parts-list","text":"","title":"Robot Faces Parts List"},{"location":"parts-lists/#microcontrollers","text":"You can use any microcontroller that supports an SPI interface and has a MicroPython driver. Here are some of our favorites.","title":"Microcontrollers"},{"location":"parts-lists/#raspberry-pi-pico","text":"The Raspberry Pi Pico is a $4 microcontroller that supports SPI. This allows you to test your face drawing for under $25.","title":"Raspberry Pi Pico"},{"location":"parts-lists/#cytron-maker-pi-rp2040","text":"","title":"Cytron Maker Pi RP2040"},{"location":"parts-lists/#displays","text":"","title":"Displays"},{"location":"parts-lists/#128x64-oleds","text":"We love the $20 128x64 OLED displays. These displays have fast SPI drivers that will update the display in around 2 milliseconds.","title":"128X64 OLEDs"},{"location":"parts-lists/#robot-chassis","text":"We use a standard \"Smart Car\" chassis to drive our cars. These parts can be purchased for around $5 each in quantity 10.","title":"Robot Chassis"},{"location":"parts-lists/#sensors","text":"This course is not intended to be a complete guide to sensors, but here are a few favorite sensors our students like to use.","title":"Sensors"},{"location":"parts-lists/#momentary-push-buttons","text":"We use momentary push buttons that are ideal for changing the mode of a robot. They can be purchased for about 10 cents in quantity 10.","title":"Momentary Push Buttons"},{"location":"parts-lists/#potentiometers","text":"These are ideal for allowing students to vary a parameter of a face such as the curvature or width of a smile.","title":"Potentiometers"},{"location":"parts-lists/#rotary-encoders","text":"","title":"Rotary Encoders"},{"location":"parts-lists/#solderless-breadboard","text":"We use $2 solderless mini breadboards to test our displays. ~","title":"Solderless Breadboard"},{"location":"lessons/","text":"List of Lessons","title":"Introduction"},{"location":"lessons/#list-of-lessons","text":"","title":"List of Lessons"},{"location":"lessons/basic-face-layouts/","text":"Basic Face Layouts Eyes Mouth Eyebrows","title":"Basic Face Layouts"},{"location":"lessons/basic-face-layouts/#basic-face-layouts","text":"","title":"Basic Face Layouts"},{"location":"lessons/basic-face-layouts/#eyes","text":"","title":"Eyes"},{"location":"lessons/basic-face-layouts/#mouth","text":"","title":"Mouth"},{"location":"lessons/basic-face-layouts/#eyebrows","text":"","title":"Eyebrows"},{"location":"lessons/blit-commands/","text":"","title":"Blit commands"},{"location":"lessons/drawing-commands/","text":"Drawing Commands Rectangles Lines Circles Polygons","title":"Basic Drawing Commands"},{"location":"lessons/drawing-commands/#drawing-commands","text":"","title":"Drawing Commands"},{"location":"lessons/drawing-commands/#rectangles","text":"","title":"Rectangles"},{"location":"lessons/drawing-commands/#lines","text":"","title":"Lines"},{"location":"lessons/drawing-commands/#circles","text":"","title":"Circles"},{"location":"lessons/drawing-commands/#polygons","text":"","title":"Polygons"},{"location":"lessons/ellipse/","text":"Drawing Ellipses Since version 1.19.1-724 of the MicroPython runtime was released in February 2023 we have support for the framebuf Ellipse function. This function allows us to draw circles and ellipses that are both filled and un-filled. We can also draw into one or more quadrants so we can do 1/4, 1/2, or 3/4 filled ellipses. Ellipse Parameters display.ellipse(x, y, HORZ_RADIUS, VERT_RADIUS, COLOR, FILL_FLAG, QUAD_CODE) Draw an ellipse at the given location. Radii HORZ_RADIUS and VERT_RADIUS define the geometry. If HORZ_RADIUS equal the VERT_RADIUS a circle is drawn. The COLOR parameter defines the color. 0 for OFF and 1 for ON. The optional FILL_FLAG parameter can be set to True to fill the ellipse. Otherwise, just a single pixel outline is drawn. Quadrant Fill Codes The optional QUAD_CODE parameter enables drawing to be restricted to certain quadrants of the ellipse. You can add the following numbers to figure out the quadrant code: 1 - upper right 2 - upper left 4 - lower left 8 - lower right For example for the lower half of the ellipse on you add 4 + 8 = 12. Here is a complete list of the 16 possible values of the code: Code Description 0 all off 1 upper right on 2 upper left on 3 top half on 4 lower left on 5 lower left and upper right on 6 left side on 7 lower right off 9 right side on 10 upper left and lower right are on 11 all but lower left are on 12 lower half on 13 all but upper left are on 14 all but upper right are on 15 all four quadrants are drawn References MicroPython Framebuf Documentation","title":"Ellipse"},{"location":"lessons/ellipse/#drawing-ellipses","text":"Since version 1.19.1-724 of the MicroPython runtime was released in February 2023 we have support for the framebuf Ellipse function. This function allows us to draw circles and ellipses that are both filled and un-filled. We can also draw into one or more quadrants so we can do 1/4, 1/2, or 3/4 filled ellipses.","title":"Drawing Ellipses"},{"location":"lessons/ellipse/#ellipse-parameters","text":"display.ellipse(x, y, HORZ_RADIUS, VERT_RADIUS, COLOR, FILL_FLAG, QUAD_CODE) Draw an ellipse at the given location. Radii HORZ_RADIUS and VERT_RADIUS define the geometry. If HORZ_RADIUS equal the VERT_RADIUS a circle is drawn. The COLOR parameter defines the color. 0 for OFF and 1 for ON. The optional FILL_FLAG parameter can be set to True to fill the ellipse. Otherwise, just a single pixel outline is drawn.","title":"Ellipse Parameters"},{"location":"lessons/ellipse/#quadrant-fill-codes","text":"The optional QUAD_CODE parameter enables drawing to be restricted to certain quadrants of the ellipse. You can add the following numbers to figure out the quadrant code: 1 - upper right 2 - upper left 4 - lower left 8 - lower right For example for the lower half of the ellipse on you add 4 + 8 = 12. Here is a complete list of the 16 possible values of the code: Code Description 0 all off 1 upper right on 2 upper left on 3 top half on 4 lower left on 5 lower left and upper right on 6 left side on 7 lower right off 9 right side on 10 upper left and lower right are on 11 all but lower left are on 12 lower half on 13 all but upper left are on 14 all but upper right are on 15 all four quadrants are drawn","title":"Quadrant Fill Codes"},{"location":"lessons/ellipse/#references","text":"MicroPython Framebuf Documentation","title":"References"},{"location":"lessons/eye-scanner/","text":"Eye Scanner 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 from machine import Pin from utime import sleep , ticks_us from math import sqrt import framebuf import ssd1306 WIDTH = 128 # bit shifting only works when the numbers are a power of 2 HALF_WIDTH = WIDTH >> 1 QUARTER_WIDTH = HALF_WIDTH >> 1 HEIGHT = 64 HALF_HEIGHT = HEIGHT >> 1 QUARTER_HEIGHT = HALF_HEIGHT >> 1 ONE_THIRD_HEIGHT = int ( HEIGHT / 3 ) # draw readability ON = 1 OFF = 0 NO_FILL = 0 FILL = 1 clock = Pin ( 2 ) #SCL data = Pin ( 3 ) #SDA RES = machine . Pin ( 4 ) DC = machine . Pin ( 5 ) CS = machine . Pin ( 6 ) spi = machine . SPI ( 0 , sck = clock , mosi = data ) oled = ssd1306 . SSD1306_SPI ( WIDTH , HEIGHT , spi , DC , RES , CS ) phm = 18 # pupal horizontal movement range eye_dist_from_top = 21 eyeWidth = 27 eyeHeight = 10 mouth_vpos = 45 mouth_width = 40 def draw_face ( eye_direction ): oled . fill ( 0 ) # left eye oled . ellipse ( 32 , eye_dist_from_top , eyeWidth , eyeHeight , ON , FILL ) oled . ellipse ( 32 + i , eye_dist_from_top , 5 , 5 , OFF , FILL ) # right eye oled . ellipse ( 94 , eye_dist_from_top , eyeWidth , eyeHeight , ON , FILL ) oled . ellipse ( 94 + i , eye_dist_from_top , 5 , 5 , OFF , FILL ) # draw mouth # draw bottom half by doing a bitwise and of 8 and 4 oled . ellipse ( HALF_WIDTH , mouth_vpos , mouth_width , 10 , ON , NO_FILL , 12 ) oled . show () delay = .02 while True : for i in range ( - phm , phm ): draw_face ( i ) sleep ( delay ) for i in range ( phm , - phm , - 1 ): draw_face ( i ) sleep ( delay )","title":"Eye Scanner"},{"location":"lessons/eye-scanner/#eye-scanner","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 from machine import Pin from utime import sleep , ticks_us from math import sqrt import framebuf import ssd1306 WIDTH = 128 # bit shifting only works when the numbers are a power of 2 HALF_WIDTH = WIDTH >> 1 QUARTER_WIDTH = HALF_WIDTH >> 1 HEIGHT = 64 HALF_HEIGHT = HEIGHT >> 1 QUARTER_HEIGHT = HALF_HEIGHT >> 1 ONE_THIRD_HEIGHT = int ( HEIGHT / 3 ) # draw readability ON = 1 OFF = 0 NO_FILL = 0 FILL = 1 clock = Pin ( 2 ) #SCL data = Pin ( 3 ) #SDA RES = machine . Pin ( 4 ) DC = machine . Pin ( 5 ) CS = machine . Pin ( 6 ) spi = machine . SPI ( 0 , sck = clock , mosi = data ) oled = ssd1306 . SSD1306_SPI ( WIDTH , HEIGHT , spi , DC , RES , CS ) phm = 18 # pupal horizontal movement range eye_dist_from_top = 21 eyeWidth = 27 eyeHeight = 10 mouth_vpos = 45 mouth_width = 40 def draw_face ( eye_direction ): oled . fill ( 0 ) # left eye oled . ellipse ( 32 , eye_dist_from_top , eyeWidth , eyeHeight , ON , FILL ) oled . ellipse ( 32 + i , eye_dist_from_top , 5 , 5 , OFF , FILL ) # right eye oled . ellipse ( 94 , eye_dist_from_top , eyeWidth , eyeHeight , ON , FILL ) oled . ellipse ( 94 + i , eye_dist_from_top , 5 , 5 , OFF , FILL ) # draw mouth # draw bottom half by doing a bitwise and of 8 and 4 oled . ellipse ( HALF_WIDTH , mouth_vpos , mouth_width , 10 , ON , NO_FILL , 12 ) oled . show () delay = .02 while True : for i in range ( - phm , phm ): draw_face ( i ) sleep ( delay ) for i in range ( phm , - phm , - 1 ): draw_face ( i ) sleep ( delay )","title":"Eye Scanner"},{"location":"lessons/eyebrows/","text":"Adding Eyebrows to a Face In this lesson, we will add eyebrows to our basic face layout. We will use the framebuf poly that is available in 1.19 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 ''' Test of the MicroPython framebuf poly drawing function from array import array my_array = array('h', [60,10, 50,60, 40,30]) display.poly(0,0, my_array, ON, FILL) ''' from machine import Pin from utime import sleep , ticks_us from array import array import framebuf import ssd1306 WIDTH = 128 # bit shifting only works when the numbers are a power of 2 HALF_WIDTH = WIDTH >> 1 QUARTER_WIDTH = HALF_WIDTH >> 1 HEIGHT = 64 HALF_HEIGHT = HEIGHT >> 1 QUARTER_HEIGHT = HALF_HEIGHT >> 1 ONE_THIRD_HEIGHT = int ( HEIGHT / 3 ) # draw readability ON = 1 OFF = 0 NO_FILL = 0 FILL = 1 clock = Pin ( 2 ) #SCL data = Pin ( 3 ) #SDA RES = machine . Pin ( 4 ) DC = machine . Pin ( 5 ) CS = machine . Pin ( 6 ) spi = machine . SPI ( 0 , sck = clock , mosi = data ) oled = ssd1306 . SSD1306_SPI ( WIDTH , HEIGHT , spi , DC , RES , CS ) # copy onto display bottom_row_text_vpos = 57 def draw_face_grid (): oled . vline ( QUARTER_WIDTH , 0 , HEIGHT , 1 ) # x, y, len, color oled . vline ( QUARTER_WIDTH * 3 , 0 , HEIGHT , 1 ) oled . hline ( 0 , ONE_THIRD_HEIGHT , WIDTH , 1 ) phm = 18 # puple horizontal movement eye_dist_from_top = 25 eyeWidth = 27 eyeWidth_half = int ( eyeWidth / 2 ) eyeHeight = 7 mouth_vpos = 40 mouth_width = 40 pupil_width = 5 left_eyebrow = array ( 'h' , [ - eyeWidth_half , - 1 , 15 , - 5 , eyeWidth_half + 10 , 1 , 15 , - 2 ]) right_eyebrow = array ( 'h' , [ - eyeWidth_half - 10 , 1 , - 15 , - 5 , eyeWidth_half , 0 , - 15 , - 2 ]) def draw_eye ( x ): oled . ellipse ( x , eye_dist_from_top , eyeWidth , eyeHeight , ON , FILL ) # draw a black pupil on the white eye oled . ellipse ( x , eye_dist_from_top , pupil_width , pupil_width , OFF , FILL ) def draw_face ( eye_direction ): # draw_face_grid() start = ticks_us () # left eye draw_eye ( QUARTER_WIDTH ) # eyebrow oled . poly ( QUARTER_WIDTH , eye_dist_from_top - 10 , left_eyebrow , ON , FILL ) # right eye draw_eye ( QUARTER_WIDTH * 3 ) oled . poly ( QUARTER_WIDTH * 3 , eye_dist_from_top - 10 , right_eyebrow , ON , FILL ) # draw mouth # draw bottom half by doing a bitwise and of 8 and 4 oled . ellipse ( HALF_WIDTH , mouth_vpos , mouth_width , 10 , ON , NO_FILL , 12 ) end = ticks_us () drawTime = end - start # oled.text(str(drawTime), 0, bottom_row_text_vpos) oled . show () # outline box oled . fill ( 0 ) oled . rect ( 0 , 0 , WIDTH , HEIGHT , 1 ) draw_face ( 0 )","title":"Adding Eyebrows to a Face"},{"location":"lessons/eyebrows/#adding-eyebrows-to-a-face","text":"In this lesson, we will add eyebrows to our basic face layout. We will use the framebuf poly that is available in 1.19 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 ''' Test of the MicroPython framebuf poly drawing function from array import array my_array = array('h', [60,10, 50,60, 40,30]) display.poly(0,0, my_array, ON, FILL) ''' from machine import Pin from utime import sleep , ticks_us from array import array import framebuf import ssd1306 WIDTH = 128 # bit shifting only works when the numbers are a power of 2 HALF_WIDTH = WIDTH >> 1 QUARTER_WIDTH = HALF_WIDTH >> 1 HEIGHT = 64 HALF_HEIGHT = HEIGHT >> 1 QUARTER_HEIGHT = HALF_HEIGHT >> 1 ONE_THIRD_HEIGHT = int ( HEIGHT / 3 ) # draw readability ON = 1 OFF = 0 NO_FILL = 0 FILL = 1 clock = Pin ( 2 ) #SCL data = Pin ( 3 ) #SDA RES = machine . Pin ( 4 ) DC = machine . Pin ( 5 ) CS = machine . Pin ( 6 ) spi = machine . SPI ( 0 , sck = clock , mosi = data ) oled = ssd1306 . SSD1306_SPI ( WIDTH , HEIGHT , spi , DC , RES , CS ) # copy onto display bottom_row_text_vpos = 57 def draw_face_grid (): oled . vline ( QUARTER_WIDTH , 0 , HEIGHT , 1 ) # x, y, len, color oled . vline ( QUARTER_WIDTH * 3 , 0 , HEIGHT , 1 ) oled . hline ( 0 , ONE_THIRD_HEIGHT , WIDTH , 1 ) phm = 18 # puple horizontal movement eye_dist_from_top = 25 eyeWidth = 27 eyeWidth_half = int ( eyeWidth / 2 ) eyeHeight = 7 mouth_vpos = 40 mouth_width = 40 pupil_width = 5 left_eyebrow = array ( 'h' , [ - eyeWidth_half , - 1 , 15 , - 5 , eyeWidth_half + 10 , 1 , 15 , - 2 ]) right_eyebrow = array ( 'h' , [ - eyeWidth_half - 10 , 1 , - 15 , - 5 , eyeWidth_half , 0 , - 15 , - 2 ]) def draw_eye ( x ): oled . ellipse ( x , eye_dist_from_top , eyeWidth , eyeHeight , ON , FILL ) # draw a black pupil on the white eye oled . ellipse ( x , eye_dist_from_top , pupil_width , pupil_width , OFF , FILL ) def draw_face ( eye_direction ): # draw_face_grid() start = ticks_us () # left eye draw_eye ( QUARTER_WIDTH ) # eyebrow oled . poly ( QUARTER_WIDTH , eye_dist_from_top - 10 , left_eyebrow , ON , FILL ) # right eye draw_eye ( QUARTER_WIDTH * 3 ) oled . poly ( QUARTER_WIDTH * 3 , eye_dist_from_top - 10 , right_eyebrow , ON , FILL ) # draw mouth # draw bottom half by doing a bitwise and of 8 and 4 oled . ellipse ( HALF_WIDTH , mouth_vpos , mouth_width , 10 , ON , NO_FILL , 12 ) end = ticks_us () drawTime = end - start # oled.text(str(drawTime), 0, bottom_row_text_vpos) oled . show () # outline box oled . fill ( 0 ) oled . rect ( 0 , 0 , WIDTH , HEIGHT , 1 ) draw_face ( 0 )","title":"Adding Eyebrows to a Face"},{"location":"lessons/interactions/","text":"Interactions Eye Pupil Movement Blinking","title":"Interactions"},{"location":"lessons/interactions/#interactions","text":"","title":"Interactions"},{"location":"lessons/interactions/#eye-pupil-movement","text":"","title":"Eye Pupil Movement"},{"location":"lessons/interactions/#blinking","text":"","title":"Blinking"},{"location":"lessons/multiple-threads/","text":"Multiple Threads Microcontrollers have more than one core. We can delegate face updates to a second core.","title":"Multiple Threads"},{"location":"lessons/multiple-threads/#multiple-threads","text":"Microcontrollers have more than one core. We can delegate face updates to a second core.","title":"Multiple Threads"},{"location":"lessons/polygon/","text":"Drawing Polygons Since v1.19.1-724 MicroPython includes a flexible way to draw any polygon of any number of points either in outline or filled mode. To use it you must pass it an array of points. The syntax for short array initialization is as follows: 1 my_array = array('h', [30,10, 100,20, 50,60]) The letter \"h\" signals that each element will be a short integer which is normally two bytes. A signed two-byte value can be any integer in a range from -32,768 to 32,767. Since the screen is only a maximum of 128 we could use an unsigned byte with the \"B\" array notation, but we will use \"h\" for portability to larger displays. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from machine import Pin from array import array import ssd1306 clock = Pin ( 2 ) #SCL data = Pin ( 3 ) #SDA RES = machine . Pin ( 4 ) DC = machine . Pin ( 5 ) CS = machine . Pin ( 6 ) spi = machine . SPI ( 0 , sck = clock , mosi = data ) oled = ssd1306 . SSD1306_SPI ( 128 , 64 , spi , DC , RES , CS ) oled . fill ( 0 ) # draw three points in a triangle to be filled using signed two-byte integers (h) my_array = array ( 'h' , [ 30 , 10 , 100 , 20 , 50 , 60 ]) # at poing (0,0) draw a polygon with on bits and filled oled . poly ( 0 , 0 , my_array , 1 , 1 ) oled . show () This will generate the following image: Sample Polygons Here is an example program 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 from machine import Pin from utime import sleep , ticks_us from array import array import framebuf import ssd1306 WIDTH = 128 HEIGHT = 64 # draw readability variables ON = 1 # white OFF = 0 # black NO_FILL = 0 # just the border is drawn FILL = 1 # all pixels within the polygon are drawn clock = Pin ( 2 ) #SCL data = Pin ( 3 ) #SDA RES = machine . Pin ( 4 ) DC = machine . Pin ( 5 ) CS = machine . Pin ( 6 ) spi = machine . SPI ( 0 , sck = clock , mosi = data ) oled = ssd1306 . SSD1306_SPI ( WIDTH , HEIGHT , spi , DC , RES , CS ) oled . fill ( 0 ) # basic filled triangle my_array = array ( 'h' , [ 10 , 0 , 20 , 10 , 0 , 10 ]) oled . poly ( 0 , 0 , my_array , ON , FILL ) # basic outline triangle my_array = array ( 'h' , [ 30 , 0 , 40 , 10 , 20 , 10 ]) oled . poly ( 0 , 0 , my_array , ON , NO_FILL ) # basic outline pentagon my_array = array ( 'h' , [ 50 , 0 , 60 , 10 , 55 , 20 , 45 , 20 , 40 , 10 ]) oled . poly ( 0 , 0 , my_array , ON , FILL ) my_array = array ( 'h' , [ 70 , 0 , 80 , 10 , 75 , 20 , 65 , 20 , 60 , 10 ]) oled . poly ( 0 , 0 , my_array , ON , NO_FILL ) # basic outline hexagon my_array = array ( 'h' , [ 85 , 0 , 95 , 0 , 100 , 10 , 95 , 20 , 85 , 20 , 80 , 10 ]) oled . poly ( 0 , 0 , my_array , ON , FILL ) my_array = array ( 'h' , [ 105 , 0 , 115 , 0 , 120 , 10 , 115 , 20 , 105 , 20 , 100 , 10 ]) oled . poly ( 0 , 0 , my_array , ON , NO_FILL ) # octagon my_array = array ( 'h' , [ 05 , 20 , 15 , 20 , 20 , 25 , 20 , 35 , 15 , 40 , 5 , 40 , 0 , 35 , 0 , 25 ]) oled . poly ( 0 , 0 , my_array , ON , FILL ) my_array = array ( 'h' , [ 25 , 20 , 35 , 20 , 40 , 25 , 40 , 35 , 35 , 40 , 25 , 40 , 20 , 35 , 20 , 25 ]) oled . poly ( 0 , 0 , my_array , ON , NO_FILL ) # filled five point star my_array = array ( 'h' , [ 50 , 20 , 53 , 27 , 60 , 30 , 53 , 33 , 55 , 40 , 50 , 35 , 45 , 40 , 47 , 33 , 40 , 30 , 47 , 27 ]) oled . poly ( 0 , 0 , my_array , ON , FILL ) # outlined five point star my_array = array ( 'h' , [ 70 , 20 , 73 , 27 , 80 , 30 , 73 , 33 , 75 , 40 , 70 , 35 , 65 , 40 , 67 , 33 , 60 , 30 , 67 , 27 ]) oled . poly ( 0 , 0 , my_array , ON , NO_FILL ) # filled hexagon star my_array = array ( 'h' , [ 85 , 20 , 90 , 25 , 95 , 20 , 95 , 25 , 100 , 30 , 95 , 35 , 95 , 40 , 90 , 35 , 85 , 40 , 85 , 35 , 80 , 30 , 85 , 25 ]) oled . poly ( 0 , 0 , my_array , ON , FILL ) # outlined hexagon star my_array = array ( 'h' , [ 105 , 20 , 110 , 25 , 115 , 20 , 115 , 25 , 120 , 30 , 115 , 35 , 115 , 40 , 110 , 35 , 105 , 40 , 105 , 35 , 100 , 30 , 105 , 25 ]) oled . poly ( 0 , 0 , my_array , ON , NO_FILL ) # filled rocket my_array = array ( 'h' , [ 0 , 45 , 5 , 50 , 20 , 50 , 20 , 45 , 25 , 53 , 20 , 60 , 20 , 55 , 5 , 55 , 0 , 60 ]) oled . poly ( 0 , 0 , my_array , ON , FILL ) # solid rocket my_array = array ( 'h' , [ 30 , 45 , 35 , 50 , 50 , 50 , 50 , 45 , 55 , 52 , 55 , 54 , 50 , 60 , 50 , 55 , 35 , 55 , 30 , 60 ]) oled . poly ( 0 , 0 , my_array , ON , NO_FILL ) # house outline my_array = array ( 'h' , [ 80 , 40 , 89 , 49 , 89 , 60 , 70 , 60 , 70 , 50 ]) oled . poly ( 0 , 0 , my_array , ON , NO_FILL ) # house fill my_array = array ( 'h' , [ 101 , 40 , 111 , 50 , 111 , 60 , 91 , 60 , 91 , 50 ]) oled . poly ( 0 , 0 , my_array , ON , FILL ) oled . show () Challenge Create a drawing with a rocket flying over a house Add your own shapes When would you use rect() and ellipse() instead of poly? Modify the triangle drawing to move the points with an animation References MicroPython Framebuf Documentation MicroPython Array","title":"Polygon"},{"location":"lessons/polygon/#drawing-polygons","text":"Since v1.19.1-724 MicroPython includes a flexible way to draw any polygon of any number of points either in outline or filled mode. To use it you must pass it an array of points. The syntax for short array initialization is as follows: 1 my_array = array('h', [30,10, 100,20, 50,60]) The letter \"h\" signals that each element will be a short integer which is normally two bytes. A signed two-byte value can be any integer in a range from -32,768 to 32,767. Since the screen is only a maximum of 128 we could use an unsigned byte with the \"B\" array notation, but we will use \"h\" for portability to larger displays. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from machine import Pin from array import array import ssd1306 clock = Pin ( 2 ) #SCL data = Pin ( 3 ) #SDA RES = machine . Pin ( 4 ) DC = machine . Pin ( 5 ) CS = machine . Pin ( 6 ) spi = machine . SPI ( 0 , sck = clock , mosi = data ) oled = ssd1306 . SSD1306_SPI ( 128 , 64 , spi , DC , RES , CS ) oled . fill ( 0 ) # draw three points in a triangle to be filled using signed two-byte integers (h) my_array = array ( 'h' , [ 30 , 10 , 100 , 20 , 50 , 60 ]) # at poing (0,0) draw a polygon with on bits and filled oled . poly ( 0 , 0 , my_array , 1 , 1 ) oled . show () This will generate the following image:","title":"Drawing Polygons"},{"location":"lessons/polygon/#sample-polygons","text":"Here is an example program 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 from machine import Pin from utime import sleep , ticks_us from array import array import framebuf import ssd1306 WIDTH = 128 HEIGHT = 64 # draw readability variables ON = 1 # white OFF = 0 # black NO_FILL = 0 # just the border is drawn FILL = 1 # all pixels within the polygon are drawn clock = Pin ( 2 ) #SCL data = Pin ( 3 ) #SDA RES = machine . Pin ( 4 ) DC = machine . Pin ( 5 ) CS = machine . Pin ( 6 ) spi = machine . SPI ( 0 , sck = clock , mosi = data ) oled = ssd1306 . SSD1306_SPI ( WIDTH , HEIGHT , spi , DC , RES , CS ) oled . fill ( 0 ) # basic filled triangle my_array = array ( 'h' , [ 10 , 0 , 20 , 10 , 0 , 10 ]) oled . poly ( 0 , 0 , my_array , ON , FILL ) # basic outline triangle my_array = array ( 'h' , [ 30 , 0 , 40 , 10 , 20 , 10 ]) oled . poly ( 0 , 0 , my_array , ON , NO_FILL ) # basic outline pentagon my_array = array ( 'h' , [ 50 , 0 , 60 , 10 , 55 , 20 , 45 , 20 , 40 , 10 ]) oled . poly ( 0 , 0 , my_array , ON , FILL ) my_array = array ( 'h' , [ 70 , 0 , 80 , 10 , 75 , 20 , 65 , 20 , 60 , 10 ]) oled . poly ( 0 , 0 , my_array , ON , NO_FILL ) # basic outline hexagon my_array = array ( 'h' , [ 85 , 0 , 95 , 0 , 100 , 10 , 95 , 20 , 85 , 20 , 80 , 10 ]) oled . poly ( 0 , 0 , my_array , ON , FILL ) my_array = array ( 'h' , [ 105 , 0 , 115 , 0 , 120 , 10 , 115 , 20 , 105 , 20 , 100 , 10 ]) oled . poly ( 0 , 0 , my_array , ON , NO_FILL ) # octagon my_array = array ( 'h' , [ 05 , 20 , 15 , 20 , 20 , 25 , 20 , 35 , 15 , 40 , 5 , 40 , 0 , 35 , 0 , 25 ]) oled . poly ( 0 , 0 , my_array , ON , FILL ) my_array = array ( 'h' , [ 25 , 20 , 35 , 20 , 40 , 25 , 40 , 35 , 35 , 40 , 25 , 40 , 20 , 35 , 20 , 25 ]) oled . poly ( 0 , 0 , my_array , ON , NO_FILL ) # filled five point star my_array = array ( 'h' , [ 50 , 20 , 53 , 27 , 60 , 30 , 53 , 33 , 55 , 40 , 50 , 35 , 45 , 40 , 47 , 33 , 40 , 30 , 47 , 27 ]) oled . poly ( 0 , 0 , my_array , ON , FILL ) # outlined five point star my_array = array ( 'h' , [ 70 , 20 , 73 , 27 , 80 , 30 , 73 , 33 , 75 , 40 , 70 , 35 , 65 , 40 , 67 , 33 , 60 , 30 , 67 , 27 ]) oled . poly ( 0 , 0 , my_array , ON , NO_FILL ) # filled hexagon star my_array = array ( 'h' , [ 85 , 20 , 90 , 25 , 95 , 20 , 95 , 25 , 100 , 30 , 95 , 35 , 95 , 40 , 90 , 35 , 85 , 40 , 85 , 35 , 80 , 30 , 85 , 25 ]) oled . poly ( 0 , 0 , my_array , ON , FILL ) # outlined hexagon star my_array = array ( 'h' , [ 105 , 20 , 110 , 25 , 115 , 20 , 115 , 25 , 120 , 30 , 115 , 35 , 115 , 40 , 110 , 35 , 105 , 40 , 105 , 35 , 100 , 30 , 105 , 25 ]) oled . poly ( 0 , 0 , my_array , ON , NO_FILL ) # filled rocket my_array = array ( 'h' , [ 0 , 45 , 5 , 50 , 20 , 50 , 20 , 45 , 25 , 53 , 20 , 60 , 20 , 55 , 5 , 55 , 0 , 60 ]) oled . poly ( 0 , 0 , my_array , ON , FILL ) # solid rocket my_array = array ( 'h' , [ 30 , 45 , 35 , 50 , 50 , 50 , 50 , 45 , 55 , 52 , 55 , 54 , 50 , 60 , 50 , 55 , 35 , 55 , 30 , 60 ]) oled . poly ( 0 , 0 , my_array , ON , NO_FILL ) # house outline my_array = array ( 'h' , [ 80 , 40 , 89 , 49 , 89 , 60 , 70 , 60 , 70 , 50 ]) oled . poly ( 0 , 0 , my_array , ON , NO_FILL ) # house fill my_array = array ( 'h' , [ 101 , 40 , 111 , 50 , 111 , 60 , 91 , 60 , 91 , 50 ]) oled . poly ( 0 , 0 , my_array , ON , FILL ) oled . show () Challenge Create a drawing with a rocket flying over a house Add your own shapes When would you use rect() and ellipse() instead of poly? Modify the triangle drawing to move the points with an animation","title":"Sample Polygons"},{"location":"lessons/polygon/#references","text":"MicroPython Framebuf Documentation MicroPython Array","title":"References"},{"location":"lessons/screen-coordinates/","text":"Screen Coordinates In these labs, our robot faces will use a low-cost OLED screen that is 128 pixels wide and 64 pixels high. This screen is big enough to draw faces but small enough to be drawn quickly by our microcontrollers. The grid layout places the origin (0,0) in the upper-left corner of the screen. The horizontal direction is always given first as the distance from the left edge to the point. This is called the X direction. The distance from the top edges of the screen to any point is called the Y direction. Note Our graphics drawing uses the opposite vertical origin to the coordinate system taught in many math classes where the origin is in the lower-left corner of the grid. In the figure above, note that the point in the upper right is (127,0)","title":"Screen Coordinates"},{"location":"lessons/screen-coordinates/#screen-coordinates","text":"In these labs, our robot faces will use a low-cost OLED screen that is 128 pixels wide and 64 pixels high. This screen is big enough to draw faces but small enough to be drawn quickly by our microcontrollers. The grid layout places the origin (0,0) in the upper-left corner of the screen. The horizontal direction is always given first as the distance from the left edge to the point. This is called the X direction. The distance from the top edges of the screen to any point is called the Y direction. Note Our graphics drawing uses the opposite vertical origin to the coordinate system taught in many math classes where the origin is in the lower-left corner of the grid. In the figure above, note that the point in the upper right is (127,0)","title":"Screen Coordinates"}]}