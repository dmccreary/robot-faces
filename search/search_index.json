{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Robot Faces This guide will help you learn how to draw fun faces on your robots. We use bright 128x64 OLED displays that cost about $20. We use simple MicroPython code so students can create their own personalized robot faces.","title":"Home"},{"location":"#welcome-to-robot-faces","text":"This guide will help you learn how to draw fun faces on your robots. We use bright 128x64 OLED displays that cost about $20. We use simple MicroPython code so students can create their own personalized robot faces.","title":"Welcome to Robot Faces"},{"location":"about/","text":"About The Robot Faces Book The book is designed to be a fun way to teach concepts in computational thinking by teaching students how to draw faces on a low-cost OLED display. It was designed to use low-cost parts to keep robot kits as low as possible. Most classrooms can create projects for under $35 per robot if you purchase parts in a quantity of 10. Primary Goals Create hands-on lessons that are fun for students Teach fundamentals of computational thinking such as abstractions, functions and modularity Decompose a complex face into parts (eyes, eyebrows, mouth) with parameters Get students to think about how faces are used to communicate emotions Sample faces from the Miko Social Robot","title":"About The Robot Faces Book"},{"location":"about/#about-the-robot-faces-book","text":"The book is designed to be a fun way to teach concepts in computational thinking by teaching students how to draw faces on a low-cost OLED display. It was designed to use low-cost parts to keep robot kits as low as possible. Most classrooms can create projects for under $35 per robot if you purchase parts in a quantity of 10.","title":"About The Robot Faces Book"},{"location":"about/#primary-goals","text":"Create hands-on lessons that are fun for students Teach fundamentals of computational thinking such as abstractions, functions and modularity Decompose a complex face into parts (eyes, eyebrows, mouth) with parameters Get students to think about how faces are used to communicate emotions Sample faces from the Miko Social Robot","title":"Primary Goals"},{"location":"contact/","text":"Contact Dan McCreary","title":"Contact"},{"location":"contact/#contact","text":"Dan McCreary","title":"Contact"},{"location":"getting-started/","text":"Getting Started with Robot Faces Here are the steps you can use to get started drawing your own robot faces. Step 1: Getting Hardware You can order the parts online or work with one of our programs that supply parts for classrooms. The minimal drawing kit contains: A Raspberry Pi Pico A mini solderless [Breadboard]../docs/parts-lists/#solderless-breadboard) An OLED display M-F jumper wires Step 2: Installing Software We use the \"Thonny\" editor to program our faces. To use it you will need to: Download and install Thonny Initialize the runtime by using the Thonny Tools -> Options -> Interpreter and select the Raspberry Pi Pico option Press the Install Runtime button Press the Stop/Reset and you should see the prompt: 1 2 3 4 5 >>> \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 MicroPython v1.19.1-854-g35524a6fd on 2023-02-07; Raspberry Pi Pico with RP2040 Type \"help()\" for more information. >>> Drawing Your Fist Face You can now copy our \"simple-face.py\" program into your microcontroller into your Thonny program and press the green \"Run\" button. You will see the following on your display:","title":"Getting Started"},{"location":"getting-started/#getting-started-with-robot-faces","text":"Here are the steps you can use to get started drawing your own robot faces.","title":"Getting Started with Robot Faces"},{"location":"getting-started/#step-1-getting-hardware","text":"You can order the parts online or work with one of our programs that supply parts for classrooms. The minimal drawing kit contains: A Raspberry Pi Pico A mini solderless [Breadboard]../docs/parts-lists/#solderless-breadboard) An OLED display M-F jumper wires","title":"Step 1: Getting Hardware"},{"location":"getting-started/#step-2-installing-software","text":"We use the \"Thonny\" editor to program our faces. To use it you will need to: Download and install Thonny Initialize the runtime by using the Thonny Tools -> Options -> Interpreter and select the Raspberry Pi Pico option Press the Install Runtime button Press the Stop/Reset and you should see the prompt: 1 2 3 4 5 >>> \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 MicroPython v1.19.1-854-g35524a6fd on 2023-02-07; Raspberry Pi Pico with RP2040 Type \"help()\" for more information. >>>","title":"Step 2: Installing Software"},{"location":"getting-started/#drawing-your-fist-face","text":"You can now copy our \"simple-face.py\" program into your microcontroller into your Thonny program and press the green \"Run\" button. You will see the following on your display:","title":"Drawing Your Fist Face"},{"location":"glossary/","text":"Robot Faces Glossary of Terms Blit Block transfer Ellipse RP2040","title":"Glossary"},{"location":"glossary/#robot-faces-glossary-of-terms","text":"","title":"Robot Faces Glossary of Terms"},{"location":"glossary/#blit","text":"Block transfer","title":"Blit"},{"location":"glossary/#ellipse","text":"","title":"Ellipse"},{"location":"glossary/#rp2040","text":"","title":"RP2040"},{"location":"parts-lists/","text":"Robot Faces Parts List Microcontrollers You can use any microcontroller that supports an SPI interface and has a MicroPython driver. Here are some of our favorites. Raspberry Pi Pico The Raspberry Pi Pico is a $4 microcontroller that supports SPI. This allows you to test your face drawing for under $25. Cytron Maker Pi RP2040 Displays 128X64 OLEDs We love the $20 128x64 OLED displays. These displays have fast SPI drivers that will update the display in around 2 milliseconds. Robot Chassis We use a standard \"Smart Car\" chassis to drive our cars. These parts can be purchased for around $5 each in quantity 10. Sensors This course is not intended to be a complete guide to sensors, but here are a few favorite sensors our students like to use. Momentary Push Buttons We use momentary push buttons that are ideal for changing the mode of a robot. They can be purchased for about 10 cents in quantity 10. Potentiometers These are ideal for allowing students to vary a parameter of a face such as the curvature or width of a smile. Rotary Encoders Solderless Breadboard We use $2 solderless mini breadboards to test our displays. ~","title":"Robot Faces Parts List"},{"location":"parts-lists/#robot-faces-parts-list","text":"","title":"Robot Faces Parts List"},{"location":"parts-lists/#microcontrollers","text":"You can use any microcontroller that supports an SPI interface and has a MicroPython driver. Here are some of our favorites.","title":"Microcontrollers"},{"location":"parts-lists/#raspberry-pi-pico","text":"The Raspberry Pi Pico is a $4 microcontroller that supports SPI. This allows you to test your face drawing for under $25.","title":"Raspberry Pi Pico"},{"location":"parts-lists/#cytron-maker-pi-rp2040","text":"","title":"Cytron Maker Pi RP2040"},{"location":"parts-lists/#displays","text":"","title":"Displays"},{"location":"parts-lists/#128x64-oleds","text":"We love the $20 128x64 OLED displays. These displays have fast SPI drivers that will update the display in around 2 milliseconds.","title":"128X64 OLEDs"},{"location":"parts-lists/#robot-chassis","text":"We use a standard \"Smart Car\" chassis to drive our cars. These parts can be purchased for around $5 each in quantity 10.","title":"Robot Chassis"},{"location":"parts-lists/#sensors","text":"This course is not intended to be a complete guide to sensors, but here are a few favorite sensors our students like to use.","title":"Sensors"},{"location":"parts-lists/#momentary-push-buttons","text":"We use momentary push buttons that are ideal for changing the mode of a robot. They can be purchased for about 10 cents in quantity 10.","title":"Momentary Push Buttons"},{"location":"parts-lists/#potentiometers","text":"These are ideal for allowing students to vary a parameter of a face such as the curvature or width of a smile.","title":"Potentiometers"},{"location":"parts-lists/#rotary-encoders","text":"","title":"Rotary Encoders"},{"location":"parts-lists/#solderless-breadboard","text":"We use $2 solderless mini breadboards to test our displays. ~","title":"Solderless Breadboard"},{"location":"references/","text":"References Emotive Response to a Hybrid-Face Robot and Translation to Consumer Social Robots Maitreyee Wairagkar et. el., 2020 C. L. Breazeal, Designing sociable robots (Intelligent robots and autonomous agents). Cambridge, Mass.: MIT Press, 2002, pp. xviii, 263 p. The role of emotions in the consumer meaning-making of interactions with social robots Paul Ekman's Family Guide to the Pixar Movie Inside Out","title":"References"},{"location":"references/#references","text":"Emotive Response to a Hybrid-Face Robot and Translation to Consumer Social Robots Maitreyee Wairagkar et. el., 2020 C. L. Breazeal, Designing sociable robots (Intelligent robots and autonomous agents). Cambridge, Mass.: MIT Press, 2002, pp. xviii, 263 p. The role of emotions in the consumer meaning-making of interactions with social robots Paul Ekman's Family Guide to the Pixar Movie Inside Out","title":"References"},{"location":"lessons/","text":"List of Lessons","title":"Introduction"},{"location":"lessons/#list-of-lessons","text":"","title":"List of Lessons"},{"location":"lessons/basic-face-layouts/","text":"Basic Face Layouts Drawing Constants 1 2 3 4 5 6 7 8 9 10 11 12 HALF_WIDTH = int ( WIDTH / 2 ) QUARTER_WIDTH = int ( WIDTH / 4 ) HALF_HEIGHT = int ( HEIGHT / 2 ) QUARTER_HEIGHT = int ( HEIGHT / 4 ) WHITE = 1 # 1 is for pixel on BLACK = 0 # 0 is for pixel off NO_FILL = 0 # 0 is for only drawing the outline FILL = 1 # 1 for filling all the pixels in an ellipse BOTTOM_HALF = 12 # this is for drawing the lower half of an ellipse The Face Outline Let's start out by drawing an outline of the face as a wide white ellipse on a black background. You don't really need to do this part because people can assume the entire screen is the face. We are mostly doing it to get you familiar with drawing with the ellispe() function. if our screen is 128 pixels wide, make the face be 100 wide FACE_WIDTH = 100 # 50 over for the left and 50 to the right if our screen is 64 pixels high, make our face be 60 high FACE_HEIGHT = 60 # 20 up and 20 down Remember that the six main parameters of the ellipse function are: 1 display . ellipse ( x , y , width , hight , color , fill ) Here is a sample face outline: 1 oled . ellipse ( HALF_WIDTH , HALF_HEIGHT , int ( FACE_WIDTH / 2 ), int ( FACE_HEIGHT / 2 ), WHITE , FILL ) Here are the parameters in detail: Center of Face - the x,y of the ellipse are HALF_WIDTH, HALF_HEIGHT so it is drawn in the center of the display Width and Height of the Face - this is the interger values of half the FACE_WIDTH and half the FACE_HEIGHT Draw with White - this is the WHITE parameter Fill not Outline - this is the FILL parameter Eyes Our eyes can start out by just being two circles. They need to be drawn about 1/3 to 1/2 of the way down the face. This is called the \"eye height\" and is measured from the top of the display. 1 2 3 4 5 6 EYE_SIZE = 10 # eyes - black on a white face # eye on the left side of the display oled . ellipse ( QUARTER_WIDTH + 10 , QUARTER_HEIGHT + 10 , EYE_SIZE , EYE_SIZE , BLACK , FILL ) # eye on the right side of the display oled . ellipse ( QUARTER_WIDTH * 3 - 10 , QUARTER_HEIGHT + 10 , EYE_SIZE , EYE_SIZE , BLACK , FILL ) Note that here, when I draw the eyes at 1/4 and 3/4 of the width, they seemed too far apart. So I added 10 to the left eye and subtracted 10 from the right eye. I also didn't quite like the eyes at 1/4 of the height so I add 10 to each of the eyes distance from the top. Mouth To draw a black mouth on a white face we will use the ellipse drawing option to only draw the bottom half of the ellipse. To do this we just add one more parameter which has a value of 12. 1 oled . ellipse ( HALF_WIDTH , HALF_HEIGHT + 10 , 30 , 10 , BLACK , FILL , BOTTOM_HALF ) In this case, I moved the vertical distance down 10 from the center of the display. I made the mouth be 60 pixels wided (twice the horizontal radius of 30), and I made the height of the mouth be 20 (twice the vertical radius). Full Face Function Here is a full Python function that draws all four components of a face on your robot: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def draw_face (): # clear the display to make all pixels black oled . fill ( 0 ) # draw the face outline oled . ellipse ( HALF_WIDTH , HALF_HEIGHT , FACE_WIDTH , FACE_HEIGHT , WHITE , FILL ) # eyes - black ellipses on a white face oled . ellipse ( QUARTER_WIDTH + 10 , QUARTER_HEIGHT + 10 , EYE_SIZE , EYE_SIZE , BLACK , FILL ) oled . ellipse ( QUARTER_WIDTH * 3 - 10 , QUARTER_HEIGHT + 10 , EYE_SIZE , EYE_SIZE , BLACK , FILL ) # mouth - black on a white face oled . ellipse ( HALF_WIDTH , HALF_HEIGHT + 10 , 30 , 10 , BLACK , FILL , BOTTOM_HALF ) oled . show () Try to adjust the parameters as you see fit. See how they change the layout. Eyebrows Drawing eyebrows are a little more complicated since they can't easily be drawn by simple shapes like a rectangle, circle or ellipse. But they are very important for signaling different emotions like surprise or anger. As an exercise, do a web search for faces with different emotions and note the shape of the eyebrows. Using the Polygon Functiont to draw eyebrows. To draw a decent eyebrow we will use the powerful and slightly more complicated polygon function. Firs","title":"Basic Face Layouts"},{"location":"lessons/basic-face-layouts/#basic-face-layouts","text":"","title":"Basic Face Layouts"},{"location":"lessons/basic-face-layouts/#drawing-constants","text":"1 2 3 4 5 6 7 8 9 10 11 12 HALF_WIDTH = int ( WIDTH / 2 ) QUARTER_WIDTH = int ( WIDTH / 4 ) HALF_HEIGHT = int ( HEIGHT / 2 ) QUARTER_HEIGHT = int ( HEIGHT / 4 ) WHITE = 1 # 1 is for pixel on BLACK = 0 # 0 is for pixel off NO_FILL = 0 # 0 is for only drawing the outline FILL = 1 # 1 for filling all the pixels in an ellipse BOTTOM_HALF = 12 # this is for drawing the lower half of an ellipse","title":"Drawing Constants"},{"location":"lessons/basic-face-layouts/#the-face-outline","text":"Let's start out by drawing an outline of the face as a wide white ellipse on a black background. You don't really need to do this part because people can assume the entire screen is the face. We are mostly doing it to get you familiar with drawing with the ellispe() function.","title":"The Face Outline"},{"location":"lessons/basic-face-layouts/#if-our-screen-is-128-pixels-wide-make-the-face-be-100-wide","text":"FACE_WIDTH = 100 # 50 over for the left and 50 to the right","title":"if our screen is 128 pixels wide, make the face be 100 wide"},{"location":"lessons/basic-face-layouts/#if-our-screen-is-64-pixels-high-make-our-face-be-60-high","text":"FACE_HEIGHT = 60 # 20 up and 20 down Remember that the six main parameters of the ellipse function are: 1 display . ellipse ( x , y , width , hight , color , fill ) Here is a sample face outline: 1 oled . ellipse ( HALF_WIDTH , HALF_HEIGHT , int ( FACE_WIDTH / 2 ), int ( FACE_HEIGHT / 2 ), WHITE , FILL ) Here are the parameters in detail: Center of Face - the x,y of the ellipse are HALF_WIDTH, HALF_HEIGHT so it is drawn in the center of the display Width and Height of the Face - this is the interger values of half the FACE_WIDTH and half the FACE_HEIGHT Draw with White - this is the WHITE parameter Fill not Outline - this is the FILL parameter","title":"if our screen is 64 pixels high, make our face be 60 high"},{"location":"lessons/basic-face-layouts/#eyes","text":"Our eyes can start out by just being two circles. They need to be drawn about 1/3 to 1/2 of the way down the face. This is called the \"eye height\" and is measured from the top of the display. 1 2 3 4 5 6 EYE_SIZE = 10 # eyes - black on a white face # eye on the left side of the display oled . ellipse ( QUARTER_WIDTH + 10 , QUARTER_HEIGHT + 10 , EYE_SIZE , EYE_SIZE , BLACK , FILL ) # eye on the right side of the display oled . ellipse ( QUARTER_WIDTH * 3 - 10 , QUARTER_HEIGHT + 10 , EYE_SIZE , EYE_SIZE , BLACK , FILL ) Note that here, when I draw the eyes at 1/4 and 3/4 of the width, they seemed too far apart. So I added 10 to the left eye and subtracted 10 from the right eye. I also didn't quite like the eyes at 1/4 of the height so I add 10 to each of the eyes distance from the top.","title":"Eyes"},{"location":"lessons/basic-face-layouts/#mouth","text":"To draw a black mouth on a white face we will use the ellipse drawing option to only draw the bottom half of the ellipse. To do this we just add one more parameter which has a value of 12. 1 oled . ellipse ( HALF_WIDTH , HALF_HEIGHT + 10 , 30 , 10 , BLACK , FILL , BOTTOM_HALF ) In this case, I moved the vertical distance down 10 from the center of the display. I made the mouth be 60 pixels wided (twice the horizontal radius of 30), and I made the height of the mouth be 20 (twice the vertical radius).","title":"Mouth"},{"location":"lessons/basic-face-layouts/#full-face-function","text":"Here is a full Python function that draws all four components of a face on your robot: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def draw_face (): # clear the display to make all pixels black oled . fill ( 0 ) # draw the face outline oled . ellipse ( HALF_WIDTH , HALF_HEIGHT , FACE_WIDTH , FACE_HEIGHT , WHITE , FILL ) # eyes - black ellipses on a white face oled . ellipse ( QUARTER_WIDTH + 10 , QUARTER_HEIGHT + 10 , EYE_SIZE , EYE_SIZE , BLACK , FILL ) oled . ellipse ( QUARTER_WIDTH * 3 - 10 , QUARTER_HEIGHT + 10 , EYE_SIZE , EYE_SIZE , BLACK , FILL ) # mouth - black on a white face oled . ellipse ( HALF_WIDTH , HALF_HEIGHT + 10 , 30 , 10 , BLACK , FILL , BOTTOM_HALF ) oled . show () Try to adjust the parameters as you see fit. See how they change the layout.","title":"Full Face Function"},{"location":"lessons/basic-face-layouts/#eyebrows","text":"Drawing eyebrows are a little more complicated since they can't easily be drawn by simple shapes like a rectangle, circle or ellipse. But they are very important for signaling different emotions like surprise or anger. As an exercise, do a web search for faces with different emotions and note the shape of the eyebrows.","title":"Eyebrows"},{"location":"lessons/basic-face-layouts/#using-the-polygon-functiont-to-draw-eyebrows","text":"To draw a decent eyebrow we will use the powerful and slightly more complicated polygon function. Firs","title":"Using the Polygon Functiont to draw eyebrows."},{"location":"lessons/blit-commands/","text":"","title":"Blit commands"},{"location":"lessons/drawing-commands/","text":"Drawing Commands All of our drawing commands come from the MicroPython FrameBuf drawing primitives. These are simple drawing operations that are designed to work on microcontrollers with limited memory. Because these commands are all functions associated with the framebuffer class, they are called methods in the documentation. A typical drawing sequence has the following steps: 1 2 3 4 5 6 7 8 # clear the entire display display . fill ( 0 ) # Draw white (1) text starting at x=0 and y = 10 display . text ( 'Hello World!' , 0 , 10 , 1 ) # draw a horizontal like starting at x=0 and y=20 that is 128 pixels long display . hline ( 0 , 20 , 128 , 1 ) # this triggers the copy of the entire frame buffer in memory to the display display . show () Preamble for Drawing All our programs will have approximately the same preamble or setup that appears before our drawing. Here is a sample of this preamble: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from machine import Pin import ssd1306 WIDTH = 128 HEIGHT = 64 clock = Pin ( 2 ) #SCL data = Pin ( 3 ) #SDA RES = machine . Pin ( 4 ) DC = machine . Pin ( 5 ) CS = machine . Pin ( 6 ) spi = machine . SPI ( 0 , sck = clock , mosi = data ) display = ssd1306 . SSD1306_SPI ( WIDTH , HEIGHT , spi , DC , RES , CS ) You may have to modify the pin numbers if you are not using our standard layout. Fill display.fill(color) A color of 0 will be a blank screen. A fill of 1 will be a white screen. We typically erase an old screen at the top of an animation loop with fill(0) Rectangles rect(x, y, width, color) Lines Horizontal Line Draw a horizontal line starting a the point (x,y) of width pixels. display.hline(x, y, width, color) Vertical Line Draw a vertical line starting a the point (x,y) of height pixels. display.vline(x, y, height, color) General Line Draw a line from a set of coordinates using the given color and a thickness of 1 pixel. The line method draws the line up to a second set of coordinates display.line(x1, y1, x2, y2, color) Rectangle rect(x, y, w, h, c[, f]) Circles and Ellipse display.ellipse(x, y, HORZ_RADIUS, VERT_RADIUS, COLOR, FILL_FLAG, QUAD_CODE) There is a detailed lesson here Polygons 1 2 3 ## draw a filled in triangle my_array = array ( 'B' , [ 10 , 0 , 20 , 10 , 0 , 10 ]) oled . poly ( 0 , 0 , my_array , ON , FILL ) There is a detailed lesson here Scroll display.scroll(xstep, ystep) Shift the contents of the FrameBuffer by the given vector. This may leave a footprint of the previous colors in the FrameBuffer. BLIT blit(fbuf, x, y, key=- 1, palette=None) Draw another FrameBuffer on top of the current one at the given coordinates. If key is specified then it should be a color integer and the corresponding color will be considered transparent: all pixels with that color value will not be drawn. (If the palette is specified then the key is compared to the value from palette, not to the value directly from fbuf.) The palette argument enables blitting between FrameBuffers with differing formats. Typical usage is to render a monochrome or grayscale glyph/icon to a color display. The palette is a FrameBuffer instance whose format is that of the current FrameBuffer. The palette height is one pixel and its pixel width is the number of colors in the source FrameBuffer. The palette for an N-bit source needs 2**N pixels; the palette for a monochrome source would have 2 pixels representing background and foreground colors. The application assigns a color to each pixel in the palette. The color of the current pixel will be that of that palette pixel whose x position is the color of the corresponding source pixel.","title":"Basic Drawing Commands"},{"location":"lessons/drawing-commands/#drawing-commands","text":"All of our drawing commands come from the MicroPython FrameBuf drawing primitives. These are simple drawing operations that are designed to work on microcontrollers with limited memory. Because these commands are all functions associated with the framebuffer class, they are called methods in the documentation. A typical drawing sequence has the following steps: 1 2 3 4 5 6 7 8 # clear the entire display display . fill ( 0 ) # Draw white (1) text starting at x=0 and y = 10 display . text ( 'Hello World!' , 0 , 10 , 1 ) # draw a horizontal like starting at x=0 and y=20 that is 128 pixels long display . hline ( 0 , 20 , 128 , 1 ) # this triggers the copy of the entire frame buffer in memory to the display display . show ()","title":"Drawing Commands"},{"location":"lessons/drawing-commands/#preamble-for-drawing","text":"All our programs will have approximately the same preamble or setup that appears before our drawing. Here is a sample of this preamble: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from machine import Pin import ssd1306 WIDTH = 128 HEIGHT = 64 clock = Pin ( 2 ) #SCL data = Pin ( 3 ) #SDA RES = machine . Pin ( 4 ) DC = machine . Pin ( 5 ) CS = machine . Pin ( 6 ) spi = machine . SPI ( 0 , sck = clock , mosi = data ) display = ssd1306 . SSD1306_SPI ( WIDTH , HEIGHT , spi , DC , RES , CS ) You may have to modify the pin numbers if you are not using our standard layout.","title":"Preamble for Drawing"},{"location":"lessons/drawing-commands/#fill","text":"display.fill(color) A color of 0 will be a blank screen. A fill of 1 will be a white screen. We typically erase an old screen at the top of an animation loop with fill(0)","title":"Fill"},{"location":"lessons/drawing-commands/#rectangles","text":"rect(x, y, width, color)","title":"Rectangles"},{"location":"lessons/drawing-commands/#lines","text":"","title":"Lines"},{"location":"lessons/drawing-commands/#horizontal-line","text":"Draw a horizontal line starting a the point (x,y) of width pixels. display.hline(x, y, width, color)","title":"Horizontal Line"},{"location":"lessons/drawing-commands/#vertical-line","text":"Draw a vertical line starting a the point (x,y) of height pixels. display.vline(x, y, height, color)","title":"Vertical Line"},{"location":"lessons/drawing-commands/#general-line","text":"Draw a line from a set of coordinates using the given color and a thickness of 1 pixel. The line method draws the line up to a second set of coordinates display.line(x1, y1, x2, y2, color)","title":"General Line"},{"location":"lessons/drawing-commands/#rectangle","text":"rect(x, y, w, h, c[, f])","title":"Rectangle"},{"location":"lessons/drawing-commands/#circles-and-ellipse","text":"display.ellipse(x, y, HORZ_RADIUS, VERT_RADIUS, COLOR, FILL_FLAG, QUAD_CODE) There is a detailed lesson here","title":"Circles and Ellipse"},{"location":"lessons/drawing-commands/#polygons","text":"1 2 3 ## draw a filled in triangle my_array = array ( 'B' , [ 10 , 0 , 20 , 10 , 0 , 10 ]) oled . poly ( 0 , 0 , my_array , ON , FILL ) There is a detailed lesson here","title":"Polygons"},{"location":"lessons/drawing-commands/#scroll","text":"display.scroll(xstep, ystep) Shift the contents of the FrameBuffer by the given vector. This may leave a footprint of the previous colors in the FrameBuffer.","title":"Scroll"},{"location":"lessons/drawing-commands/#blit","text":"blit(fbuf, x, y, key=- 1, palette=None) Draw another FrameBuffer on top of the current one at the given coordinates. If key is specified then it should be a color integer and the corresponding color will be considered transparent: all pixels with that color value will not be drawn. (If the palette is specified then the key is compared to the value from palette, not to the value directly from fbuf.) The palette argument enables blitting between FrameBuffers with differing formats. Typical usage is to render a monochrome or grayscale glyph/icon to a color display. The palette is a FrameBuffer instance whose format is that of the current FrameBuffer. The palette height is one pixel and its pixel width is the number of colors in the source FrameBuffer. The palette for an N-bit source needs 2**N pixels; the palette for a monochrome source would have 2 pixels representing background and foreground colors. The application assigns a color to each pixel in the palette. The color of the current pixel will be that of that palette pixel whose x position is the color of the corresponding source pixel.","title":"BLIT"},{"location":"lessons/ellipse/","text":"Drawing Ellipses Since version 1.19.1-724 of the MicroPython runtime was released in February 2023 we have support for the framebuf Ellipse function. This function allows us to draw circles and ellipses that are both filled and un-filled. We can also draw into one or more quadrants so we can do 1/4, 1/2, or 3/4 filled ellipses. Sample Program Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # Test of the micropython ellipse function # display.ellipse(x, y, HORZ_RADIUS, VERT_RADIUS, COLOR, FILL_FLAG, QUAD_CODE) from machine import Pin from utime import sleep import framebuf import ssd1306 WIDTH = 128 HEIGHT = 64 clock = Pin ( 2 ) #SCL data = Pin ( 3 ) #SDA RES = machine . Pin ( 4 ) DC = machine . Pin ( 5 ) CS = machine . Pin ( 6 ) spi = machine . SPI ( 0 , sck = clock , mosi = data ) oled = ssd1306 . SSD1306_SPI ( WIDTH , HEIGHT , spi , DC , RES , CS ) # center the ellipse in the middle of the display x = int ( WIDTH / 2 ) y = int ( HEIGHT / 2 ) HORZ_RADIUS = 30 # 30 over for the left and 30 to the right VERT_RADIUS = 20 # 20 up and 20 down COLOR = 1 # 0 or 1 # draw an ellipse wihout the fill oled . ellipse ( x , y , HORZ_RADIUS , VERT_RADIUS , COLOR ) oled . show () Ellipse Parameters display.ellipse(x, y, HORZ_RADIUS, VERT_RADIUS, COLOR, FILL_FLAG, QUAD_CODE) Draw an ellipse at the given location. Radii HORZ_RADIUS and VERT_RADIUS define the geometry. If HORZ_RADIUS equal the VERT_RADIUS a circle is drawn. The COLOR parameter defines the color. 0 for OFF and 1 for ON. The optional FILL_FLAG parameter can be set to True to fill the ellipse. Otherwise, just a single pixel outline is drawn. Quadrant Fill Codes The optional QUAD_CODE parameter enables drawing to be restricted to certain quadrants of the ellipse. You can add the following numbers to figure out the quadrant code: 1 - upper right 2 - upper left 4 - lower left 8 - lower right For example for the lower half of the ellipse on you add 4 + 8 = 12. Here is a complete list of the 16 possible values of the code: Code Description 0 all off 1 upper right on 2 upper left on 3 top half on 4 lower left on 5 lower left and upper right on 6 left side on 7 lower right off 9 right side on 10 upper left and lower right are on 11 all but lower left are on 12 lower half on 13 all but upper left are on 14 all but upper right are on 15 all four quadrants are drawn References MicroPython Framebuf Documentation","title":"Ellipse"},{"location":"lessons/ellipse/#drawing-ellipses","text":"Since version 1.19.1-724 of the MicroPython runtime was released in February 2023 we have support for the framebuf Ellipse function. This function allows us to draw circles and ellipses that are both filled and un-filled. We can also draw into one or more quadrants so we can do 1/4, 1/2, or 3/4 filled ellipses.","title":"Drawing Ellipses"},{"location":"lessons/ellipse/#sample-program-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # Test of the micropython ellipse function # display.ellipse(x, y, HORZ_RADIUS, VERT_RADIUS, COLOR, FILL_FLAG, QUAD_CODE) from machine import Pin from utime import sleep import framebuf import ssd1306 WIDTH = 128 HEIGHT = 64 clock = Pin ( 2 ) #SCL data = Pin ( 3 ) #SDA RES = machine . Pin ( 4 ) DC = machine . Pin ( 5 ) CS = machine . Pin ( 6 ) spi = machine . SPI ( 0 , sck = clock , mosi = data ) oled = ssd1306 . SSD1306_SPI ( WIDTH , HEIGHT , spi , DC , RES , CS ) # center the ellipse in the middle of the display x = int ( WIDTH / 2 ) y = int ( HEIGHT / 2 ) HORZ_RADIUS = 30 # 30 over for the left and 30 to the right VERT_RADIUS = 20 # 20 up and 20 down COLOR = 1 # 0 or 1 # draw an ellipse wihout the fill oled . ellipse ( x , y , HORZ_RADIUS , VERT_RADIUS , COLOR ) oled . show ()","title":"Sample Program Code"},{"location":"lessons/ellipse/#ellipse-parameters","text":"display.ellipse(x, y, HORZ_RADIUS, VERT_RADIUS, COLOR, FILL_FLAG, QUAD_CODE) Draw an ellipse at the given location. Radii HORZ_RADIUS and VERT_RADIUS define the geometry. If HORZ_RADIUS equal the VERT_RADIUS a circle is drawn. The COLOR parameter defines the color. 0 for OFF and 1 for ON. The optional FILL_FLAG parameter can be set to True to fill the ellipse. Otherwise, just a single pixel outline is drawn.","title":"Ellipse Parameters"},{"location":"lessons/ellipse/#quadrant-fill-codes","text":"The optional QUAD_CODE parameter enables drawing to be restricted to certain quadrants of the ellipse. You can add the following numbers to figure out the quadrant code: 1 - upper right 2 - upper left 4 - lower left 8 - lower right For example for the lower half of the ellipse on you add 4 + 8 = 12. Here is a complete list of the 16 possible values of the code: Code Description 0 all off 1 upper right on 2 upper left on 3 top half on 4 lower left on 5 lower left and upper right on 6 left side on 7 lower right off 9 right side on 10 upper left and lower right are on 11 all but lower left are on 12 lower half on 13 all but upper left are on 14 all but upper right are on 15 all four quadrants are drawn","title":"Quadrant Fill Codes"},{"location":"lessons/ellipse/#references","text":"MicroPython Framebuf Documentation","title":"References"},{"location":"lessons/emotion-types/","text":"Emotion Types This project puts a focus on using MicroPython and OLED displays to generate about seven primary emotions . Here are the seven faces that Paul Ekman describes in his research: happy sad angry afraid surprise disgust contempt The feeling of tied or sleepy can also be shown on a robots face. Here are photos of these seven emotions on people: Inside Out Emotions The Pixar movie Inside Out focused on only five emotions in its characters: Joy Sadness Fear Disgust Anger Some of these emotions are easy for people to recognize. Here is this list sorted by confidence take from a table in Emotive Response to a Hybrid-Face Robot and Translation to Consumer Social Robots : OVERALL EMOTION RECOGNITION ACCURACIES Sad: 88% Happy: 84.8 Surprise: 79.6 Tired: 69.0 Angry: 68.5 Disgust: 63.8 Stern: 59.2 Note that the emotion of contempt was not scored in this paper. References Ekman and Friesen","title":"Emotion Types"},{"location":"lessons/emotion-types/#emotion-types","text":"This project puts a focus on using MicroPython and OLED displays to generate about seven primary emotions . Here are the seven faces that Paul Ekman describes in his research: happy sad angry afraid surprise disgust contempt The feeling of tied or sleepy can also be shown on a robots face. Here are photos of these seven emotions on people:","title":"Emotion Types"},{"location":"lessons/emotion-types/#inside-out-emotions","text":"The Pixar movie Inside Out focused on only five emotions in its characters: Joy Sadness Fear Disgust Anger Some of these emotions are easy for people to recognize. Here is this list sorted by confidence take from a table in Emotive Response to a Hybrid-Face Robot and Translation to Consumer Social Robots : OVERALL EMOTION RECOGNITION ACCURACIES Sad: 88% Happy: 84.8 Surprise: 79.6 Tired: 69.0 Angry: 68.5 Disgust: 63.8 Stern: 59.2 Note that the emotion of contempt was not scored in this paper.","title":"Inside Out Emotions"},{"location":"lessons/emotion-types/#references","text":"Ekman and Friesen","title":"References"},{"location":"lessons/eye-scanner/","text":"Eye Scanner 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 from machine import Pin from utime import sleep , ticks_us from math import sqrt import framebuf import ssd1306 WIDTH = 128 # bit shifting only works when the numbers are a power of 2 HALF_WIDTH = WIDTH >> 1 QUARTER_WIDTH = HALF_WIDTH >> 1 HEIGHT = 64 HALF_HEIGHT = HEIGHT >> 1 QUARTER_HEIGHT = HALF_HEIGHT >> 1 ONE_THIRD_HEIGHT = int ( HEIGHT / 3 ) # draw readability ON = 1 OFF = 0 NO_FILL = 0 FILL = 1 clock = Pin ( 2 ) #SCL data = Pin ( 3 ) #SDA RES = machine . Pin ( 4 ) DC = machine . Pin ( 5 ) CS = machine . Pin ( 6 ) spi = machine . SPI ( 0 , sck = clock , mosi = data ) oled = ssd1306 . SSD1306_SPI ( WIDTH , HEIGHT , spi , DC , RES , CS ) phm = 18 # pupal horizontal movement range eye_dist_from_top = 21 eyeWidth = 27 eyeHeight = 10 mouth_vpos = 45 mouth_width = 40 def draw_face ( eye_direction ): oled . fill ( 0 ) # left eye oled . ellipse ( 32 , eye_dist_from_top , eyeWidth , eyeHeight , ON , FILL ) oled . ellipse ( 32 + i , eye_dist_from_top , 5 , 5 , OFF , FILL ) # right eye oled . ellipse ( 94 , eye_dist_from_top , eyeWidth , eyeHeight , ON , FILL ) oled . ellipse ( 94 + i , eye_dist_from_top , 5 , 5 , OFF , FILL ) # draw mouth # draw bottom half by doing a bitwise and of 8 and 4 oled . ellipse ( HALF_WIDTH , mouth_vpos , mouth_width , 10 , ON , NO_FILL , 12 ) oled . show () delay = .02 while True : for i in range ( - phm , phm ): draw_face ( i ) sleep ( delay ) for i in range ( phm , - phm , - 1 ): draw_face ( i ) sleep ( delay )","title":"Eye Scanner"},{"location":"lessons/eye-scanner/#eye-scanner","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 from machine import Pin from utime import sleep , ticks_us from math import sqrt import framebuf import ssd1306 WIDTH = 128 # bit shifting only works when the numbers are a power of 2 HALF_WIDTH = WIDTH >> 1 QUARTER_WIDTH = HALF_WIDTH >> 1 HEIGHT = 64 HALF_HEIGHT = HEIGHT >> 1 QUARTER_HEIGHT = HALF_HEIGHT >> 1 ONE_THIRD_HEIGHT = int ( HEIGHT / 3 ) # draw readability ON = 1 OFF = 0 NO_FILL = 0 FILL = 1 clock = Pin ( 2 ) #SCL data = Pin ( 3 ) #SDA RES = machine . Pin ( 4 ) DC = machine . Pin ( 5 ) CS = machine . Pin ( 6 ) spi = machine . SPI ( 0 , sck = clock , mosi = data ) oled = ssd1306 . SSD1306_SPI ( WIDTH , HEIGHT , spi , DC , RES , CS ) phm = 18 # pupal horizontal movement range eye_dist_from_top = 21 eyeWidth = 27 eyeHeight = 10 mouth_vpos = 45 mouth_width = 40 def draw_face ( eye_direction ): oled . fill ( 0 ) # left eye oled . ellipse ( 32 , eye_dist_from_top , eyeWidth , eyeHeight , ON , FILL ) oled . ellipse ( 32 + i , eye_dist_from_top , 5 , 5 , OFF , FILL ) # right eye oled . ellipse ( 94 , eye_dist_from_top , eyeWidth , eyeHeight , ON , FILL ) oled . ellipse ( 94 + i , eye_dist_from_top , 5 , 5 , OFF , FILL ) # draw mouth # draw bottom half by doing a bitwise and of 8 and 4 oled . ellipse ( HALF_WIDTH , mouth_vpos , mouth_width , 10 , ON , NO_FILL , 12 ) oled . show () delay = .02 while True : for i in range ( - phm , phm ): draw_face ( i ) sleep ( delay ) for i in range ( phm , - phm , - 1 ): draw_face ( i ) sleep ( delay )","title":"Eye Scanner"},{"location":"lessons/eyebrows/","text":"Adding Eyebrows to a Face In this lesson, we will add eyebrows to our basic face layout. We will use the framebuf poly that is available in 1.19 and higher 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 ''' Test of the MicroPython framebuf poly drawing function from array import array my_array = array('h', [60,10, 50,60, 40,30]) display.poly(0,0, my_array, ON, FILL) ''' from machine import Pin from utime import sleep , ticks_us from array import array import framebuf import ssd1306 WIDTH = 128 # bit shifting only works when the numbers are a power of 2 HALF_WIDTH = WIDTH >> 1 QUARTER_WIDTH = HALF_WIDTH >> 1 HEIGHT = 64 HALF_HEIGHT = HEIGHT >> 1 QUARTER_HEIGHT = HALF_HEIGHT >> 1 ONE_THIRD_HEIGHT = int ( HEIGHT / 3 ) # draw readability ON = 1 OFF = 0 NO_FILL = 0 FILL = 1 clock = Pin ( 2 ) #SCL data = Pin ( 3 ) #SDA RES = machine . Pin ( 4 ) DC = machine . Pin ( 5 ) CS = machine . Pin ( 6 ) spi = machine . SPI ( 0 , sck = clock , mosi = data ) oled = ssd1306 . SSD1306_SPI ( WIDTH , HEIGHT , spi , DC , RES , CS ) # copy onto display bottom_row_text_vpos = 57 def draw_face_grid (): oled . vline ( QUARTER_WIDTH , 0 , HEIGHT , 1 ) # x, y, len, color oled . vline ( QUARTER_WIDTH * 3 , 0 , HEIGHT , 1 ) oled . hline ( 0 , ONE_THIRD_HEIGHT , WIDTH , 1 ) phm = 18 # puple horizontal movement eye_dist_from_top = 25 eyeWidth = 27 eyeWidth_half = int ( eyeWidth / 2 ) eyeHeight = 7 mouth_vpos = 40 mouth_width = 40 pupil_width = 5 left_eyebrow = array ( 'h' , [ - eyeWidth_half , - 1 , 15 , - 5 , eyeWidth_half + 10 , 1 , 15 , - 2 ]) right_eyebrow = array ( 'h' , [ - eyeWidth_half - 10 , 1 , - 15 , - 5 , eyeWidth_half , 0 , - 15 , - 2 ]) def draw_eye ( x ): oled . ellipse ( x , eye_dist_from_top , eyeWidth , eyeHeight , ON , FILL ) # draw a black pupil on the white eye oled . ellipse ( x , eye_dist_from_top , pupil_width , pupil_width , OFF , FILL ) def draw_face ( eye_direction ): # draw_face_grid() start = ticks_us () # left eye draw_eye ( QUARTER_WIDTH ) # eyebrow oled . poly ( QUARTER_WIDTH , eye_dist_from_top - 10 , left_eyebrow , ON , FILL ) # right eye draw_eye ( QUARTER_WIDTH * 3 ) oled . poly ( QUARTER_WIDTH * 3 , eye_dist_from_top - 10 , right_eyebrow , ON , FILL ) # draw mouth # draw bottom half by doing a bitwise and of 8 and 4 oled . ellipse ( HALF_WIDTH , mouth_vpos , mouth_width , 10 , ON , NO_FILL , 12 ) end = ticks_us () drawTime = end - start # oled.text(str(drawTime), 0, bottom_row_text_vpos) oled . show () # outline box oled . fill ( 0 ) oled . rect ( 0 , 0 , WIDTH , HEIGHT , 1 ) draw_face ( 0 )","title":"Eyebrows"},{"location":"lessons/eyebrows/#adding-eyebrows-to-a-face","text":"In this lesson, we will add eyebrows to our basic face layout. We will use the framebuf poly that is available in 1.19 and higher 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 ''' Test of the MicroPython framebuf poly drawing function from array import array my_array = array('h', [60,10, 50,60, 40,30]) display.poly(0,0, my_array, ON, FILL) ''' from machine import Pin from utime import sleep , ticks_us from array import array import framebuf import ssd1306 WIDTH = 128 # bit shifting only works when the numbers are a power of 2 HALF_WIDTH = WIDTH >> 1 QUARTER_WIDTH = HALF_WIDTH >> 1 HEIGHT = 64 HALF_HEIGHT = HEIGHT >> 1 QUARTER_HEIGHT = HALF_HEIGHT >> 1 ONE_THIRD_HEIGHT = int ( HEIGHT / 3 ) # draw readability ON = 1 OFF = 0 NO_FILL = 0 FILL = 1 clock = Pin ( 2 ) #SCL data = Pin ( 3 ) #SDA RES = machine . Pin ( 4 ) DC = machine . Pin ( 5 ) CS = machine . Pin ( 6 ) spi = machine . SPI ( 0 , sck = clock , mosi = data ) oled = ssd1306 . SSD1306_SPI ( WIDTH , HEIGHT , spi , DC , RES , CS ) # copy onto display bottom_row_text_vpos = 57 def draw_face_grid (): oled . vline ( QUARTER_WIDTH , 0 , HEIGHT , 1 ) # x, y, len, color oled . vline ( QUARTER_WIDTH * 3 , 0 , HEIGHT , 1 ) oled . hline ( 0 , ONE_THIRD_HEIGHT , WIDTH , 1 ) phm = 18 # puple horizontal movement eye_dist_from_top = 25 eyeWidth = 27 eyeWidth_half = int ( eyeWidth / 2 ) eyeHeight = 7 mouth_vpos = 40 mouth_width = 40 pupil_width = 5 left_eyebrow = array ( 'h' , [ - eyeWidth_half , - 1 , 15 , - 5 , eyeWidth_half + 10 , 1 , 15 , - 2 ]) right_eyebrow = array ( 'h' , [ - eyeWidth_half - 10 , 1 , - 15 , - 5 , eyeWidth_half , 0 , - 15 , - 2 ]) def draw_eye ( x ): oled . ellipse ( x , eye_dist_from_top , eyeWidth , eyeHeight , ON , FILL ) # draw a black pupil on the white eye oled . ellipse ( x , eye_dist_from_top , pupil_width , pupil_width , OFF , FILL ) def draw_face ( eye_direction ): # draw_face_grid() start = ticks_us () # left eye draw_eye ( QUARTER_WIDTH ) # eyebrow oled . poly ( QUARTER_WIDTH , eye_dist_from_top - 10 , left_eyebrow , ON , FILL ) # right eye draw_eye ( QUARTER_WIDTH * 3 ) oled . poly ( QUARTER_WIDTH * 3 , eye_dist_from_top - 10 , right_eyebrow , ON , FILL ) # draw mouth # draw bottom half by doing a bitwise and of 8 and 4 oled . ellipse ( HALF_WIDTH , mouth_vpos , mouth_width , 10 , ON , NO_FILL , 12 ) end = ticks_us () drawTime = end - start # oled.text(str(drawTime), 0, bottom_row_text_vpos) oled . show () # outline box oled . fill ( 0 ) oled . rect ( 0 , 0 , WIDTH , HEIGHT , 1 ) draw_face ( 0 )","title":"Adding Eyebrows to a Face"},{"location":"lessons/interactions/","text":"Interactions Eye Pupil Movement Blinking","title":"Interactions"},{"location":"lessons/interactions/#interactions","text":"","title":"Interactions"},{"location":"lessons/interactions/#eye-pupil-movement","text":"","title":"Eye Pupil Movement"},{"location":"lessons/interactions/#blinking","text":"","title":"Blinking"},{"location":"lessons/multiple-threads/","text":"Multiple Threads Microcontrollers have more than one core. We can delegate face updates to a second core.","title":"Multiple Threads"},{"location":"lessons/multiple-threads/#multiple-threads","text":"Microcontrollers have more than one core. We can delegate face updates to a second core.","title":"Multiple Threads"},{"location":"lessons/polygon/","text":"Drawing Polygons Lesson Overview In this a lesson about how to use the poly() function to do drawing on with MicroPython. The poly() function is implemented as part of the Framebuf function in MicroPython. This means that it will run on any display that uses frame buffers. We think you will find poly() a very powerful and flexibile way to draw features on a face such as a nose or eyebrows. Drawing with the Polygon Function Since v1.19.1-724 MicroPython includes a flexible way to draw any polygon of any number of points either in outline or filled mode. With this function, you can quickly draw complex shapes such as triangles, hexagons, stars, rockets or houses. To use the poly() function we must pass it an array of points. The syntax for short array initialization is as follows: 1 my_array = array('B', [30,10, 100,20, 50,60]) The letter \"B\" signals that each element will be an unsigned byte which is enough for our purposes. Many systems use an \"h\" which is a signed two-byte value which can be any integer in a range from -32,768 to 32,767. Since our OLED screen is only a maximum of 128 the B is the most compact value, but remember that the max value is 255 and we can't store negative values in an unsigned byte. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from machine import Pin from array import array import ssd1306 clock = Pin ( 2 ) #SCL data = Pin ( 3 ) #SDA RES = machine . Pin ( 4 ) DC = machine . Pin ( 5 ) CS = machine . Pin ( 6 ) spi = machine . SPI ( 0 , sck = clock , mosi = data ) oled = ssd1306 . SSD1306_SPI ( 128 , 64 , spi , DC , RES , CS ) oled . fill ( 0 ) # draw three points in a triangle to be filled using signed two-byte integers (h) my_array = array ( 'B' , [ 30 , 10 , 100 , 20 , 50 , 60 ]) # at poing (0,0) draw a polygon with on bits and filled oled . poly ( 0 , 0 , my_array , 1 , 1 ) oled . show () This will generate the following image: Sample Polygons Here is an example program 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 from machine import Pin from utime import sleep , ticks_us from array import array import framebuf import ssd1306 WIDTH = 128 HEIGHT = 64 # draw readability variables ON = 1 # white OFF = 0 # black NO_FILL = 0 # just the border is drawn FILL = 1 # all pixels within the polygon are drawn clock = Pin ( 2 ) #SCL data = Pin ( 3 ) #SDA RES = machine . Pin ( 4 ) DC = machine . Pin ( 5 ) CS = machine . Pin ( 6 ) spi = machine . SPI ( 0 , sck = clock , mosi = data ) oled = ssd1306 . SSD1306_SPI ( WIDTH , HEIGHT , spi , DC , RES , CS ) oled . fill ( 0 ) # basic filled triangle my_array = array ( 'B' , [ 10 , 0 , 20 , 10 , 0 , 10 ]) oled . poly ( 0 , 0 , my_array , ON , FILL ) # basic outline triangle my_array = array ( 'B' , [ 30 , 0 , 40 , 10 , 20 , 10 ]) oled . poly ( 0 , 0 , my_array , ON , NO_FILL ) # basic outline pentagon my_array = array ( 'B' , [ 50 , 0 , 60 , 10 , 55 , 20 , 45 , 20 , 40 , 10 ]) oled . poly ( 0 , 0 , my_array , ON , FILL ) my_array = array ( 'B' , [ 70 , 0 , 80 , 10 , 75 , 20 , 65 , 20 , 60 , 10 ]) oled . poly ( 0 , 0 , my_array , ON , NO_FILL ) # basic outline hexagon my_array = array ( 'B' , [ 85 , 0 , 95 , 0 , 100 , 10 , 95 , 20 , 85 , 20 , 80 , 10 ]) oled . poly ( 0 , 0 , my_array , ON , FILL ) my_array = array ( 'B' , [ 105 , 0 , 115 , 0 , 120 , 10 , 115 , 20 , 105 , 20 , 100 , 10 ]) oled . poly ( 0 , 0 , my_array , ON , NO_FILL ) # octagon my_array = array ( 'B' , [ 05 , 20 , 15 , 20 , 20 , 25 , 20 , 35 , 15 , 40 , 5 , 40 , 0 , 35 , 0 , 25 ]) oled . poly ( 0 , 0 , my_array , ON , FILL ) my_array = array ( 'B' , [ 25 , 20 , 35 , 20 , 40 , 25 , 40 , 35 , 35 , 40 , 25 , 40 , 20 , 35 , 20 , 25 ]) oled . poly ( 0 , 0 , my_array , ON , NO_FILL ) # filled five point star my_array = array ( 'B' , [ 50 , 20 , 53 , 27 , 60 , 30 , 53 , 33 , 55 , 40 , 50 , 35 , 45 , 40 , 47 , 33 , 40 , 30 , 47 , 27 ]) oled . poly ( 0 , 0 , my_array , ON , FILL ) # outlined five point star my_array = array ( 'B' , [ 70 , 20 , 73 , 27 , 80 , 30 , 73 , 33 , 75 , 40 , 70 , 35 , 65 , 40 , 67 , 33 , 60 , 30 , 67 , 27 ]) oled . poly ( 0 , 0 , my_array , ON , NO_FILL ) # filled hexagon star my_array = array ( 'B' , [ 85 , 20 , 90 , 25 , 95 , 20 , 95 , 25 , 100 , 30 , 95 , 35 , 95 , 40 , 90 , 35 , 85 , 40 , 85 , 35 , 80 , 30 , 85 , 25 ]) oled . poly ( 0 , 0 , my_array , ON , FILL ) # outlined hexagon star my_array = array ( 'B' , [ 105 , 20 , 110 , 25 , 115 , 20 , 115 , 25 , 120 , 30 , 115 , 35 , 115 , 40 , 110 , 35 , 105 , 40 , 105 , 35 , 100 , 30 , 105 , 25 ]) oled . poly ( 0 , 0 , my_array , ON , NO_FILL ) # filled rocket my_array = array ( 'B' , [ 0 , 45 , 5 , 50 , 20 , 50 , 20 , 45 , 25 , 53 , 20 , 60 , 20 , 55 , 5 , 55 , 0 , 60 ]) oled . poly ( 0 , 0 , my_array , ON , FILL ) # solid rocket my_array = array ( 'B' , [ 30 , 45 , 35 , 50 , 50 , 50 , 50 , 45 , 55 , 52 , 55 , 54 , 50 , 60 , 50 , 55 , 35 , 55 , 30 , 60 ]) oled . poly ( 0 , 0 , my_array , ON , NO_FILL ) # house outline my_array = array ( 'B' , [ 80 , 40 , 89 , 49 , 89 , 60 , 70 , 60 , 70 , 50 ]) oled . poly ( 0 , 0 , my_array , ON , NO_FILL ) # house fill my_array = array ( 'B' , [ 101 , 40 , 111 , 50 , 111 , 60 , 91 , 60 , 91 , 50 ]) oled . poly ( 0 , 0 , my_array , ON , FILL ) oled . show () Challenge Create a drawing with a rocket flying over a house Add your own shapes When would you use rect() and ellipse() instead of poly? Modify the triangle drawing to move the points with an animation. Use an array of directions that reverse when the points reach the edge of the screen. solution References MicroPython Framebuf Documentation MicroPython Array","title":"Polygon"},{"location":"lessons/polygon/#drawing-polygons","text":"","title":"Drawing Polygons"},{"location":"lessons/polygon/#lesson-overview","text":"In this a lesson about how to use the poly() function to do drawing on with MicroPython. The poly() function is implemented as part of the Framebuf function in MicroPython. This means that it will run on any display that uses frame buffers. We think you will find poly() a very powerful and flexibile way to draw features on a face such as a nose or eyebrows.","title":"Lesson Overview"},{"location":"lessons/polygon/#drawing-with-the-polygon-function","text":"Since v1.19.1-724 MicroPython includes a flexible way to draw any polygon of any number of points either in outline or filled mode. With this function, you can quickly draw complex shapes such as triangles, hexagons, stars, rockets or houses. To use the poly() function we must pass it an array of points. The syntax for short array initialization is as follows: 1 my_array = array('B', [30,10, 100,20, 50,60]) The letter \"B\" signals that each element will be an unsigned byte which is enough for our purposes. Many systems use an \"h\" which is a signed two-byte value which can be any integer in a range from -32,768 to 32,767. Since our OLED screen is only a maximum of 128 the B is the most compact value, but remember that the max value is 255 and we can't store negative values in an unsigned byte. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from machine import Pin from array import array import ssd1306 clock = Pin ( 2 ) #SCL data = Pin ( 3 ) #SDA RES = machine . Pin ( 4 ) DC = machine . Pin ( 5 ) CS = machine . Pin ( 6 ) spi = machine . SPI ( 0 , sck = clock , mosi = data ) oled = ssd1306 . SSD1306_SPI ( 128 , 64 , spi , DC , RES , CS ) oled . fill ( 0 ) # draw three points in a triangle to be filled using signed two-byte integers (h) my_array = array ( 'B' , [ 30 , 10 , 100 , 20 , 50 , 60 ]) # at poing (0,0) draw a polygon with on bits and filled oled . poly ( 0 , 0 , my_array , 1 , 1 ) oled . show () This will generate the following image:","title":"Drawing with the Polygon Function"},{"location":"lessons/polygon/#sample-polygons","text":"Here is an example program 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 from machine import Pin from utime import sleep , ticks_us from array import array import framebuf import ssd1306 WIDTH = 128 HEIGHT = 64 # draw readability variables ON = 1 # white OFF = 0 # black NO_FILL = 0 # just the border is drawn FILL = 1 # all pixels within the polygon are drawn clock = Pin ( 2 ) #SCL data = Pin ( 3 ) #SDA RES = machine . Pin ( 4 ) DC = machine . Pin ( 5 ) CS = machine . Pin ( 6 ) spi = machine . SPI ( 0 , sck = clock , mosi = data ) oled = ssd1306 . SSD1306_SPI ( WIDTH , HEIGHT , spi , DC , RES , CS ) oled . fill ( 0 ) # basic filled triangle my_array = array ( 'B' , [ 10 , 0 , 20 , 10 , 0 , 10 ]) oled . poly ( 0 , 0 , my_array , ON , FILL ) # basic outline triangle my_array = array ( 'B' , [ 30 , 0 , 40 , 10 , 20 , 10 ]) oled . poly ( 0 , 0 , my_array , ON , NO_FILL ) # basic outline pentagon my_array = array ( 'B' , [ 50 , 0 , 60 , 10 , 55 , 20 , 45 , 20 , 40 , 10 ]) oled . poly ( 0 , 0 , my_array , ON , FILL ) my_array = array ( 'B' , [ 70 , 0 , 80 , 10 , 75 , 20 , 65 , 20 , 60 , 10 ]) oled . poly ( 0 , 0 , my_array , ON , NO_FILL ) # basic outline hexagon my_array = array ( 'B' , [ 85 , 0 , 95 , 0 , 100 , 10 , 95 , 20 , 85 , 20 , 80 , 10 ]) oled . poly ( 0 , 0 , my_array , ON , FILL ) my_array = array ( 'B' , [ 105 , 0 , 115 , 0 , 120 , 10 , 115 , 20 , 105 , 20 , 100 , 10 ]) oled . poly ( 0 , 0 , my_array , ON , NO_FILL ) # octagon my_array = array ( 'B' , [ 05 , 20 , 15 , 20 , 20 , 25 , 20 , 35 , 15 , 40 , 5 , 40 , 0 , 35 , 0 , 25 ]) oled . poly ( 0 , 0 , my_array , ON , FILL ) my_array = array ( 'B' , [ 25 , 20 , 35 , 20 , 40 , 25 , 40 , 35 , 35 , 40 , 25 , 40 , 20 , 35 , 20 , 25 ]) oled . poly ( 0 , 0 , my_array , ON , NO_FILL ) # filled five point star my_array = array ( 'B' , [ 50 , 20 , 53 , 27 , 60 , 30 , 53 , 33 , 55 , 40 , 50 , 35 , 45 , 40 , 47 , 33 , 40 , 30 , 47 , 27 ]) oled . poly ( 0 , 0 , my_array , ON , FILL ) # outlined five point star my_array = array ( 'B' , [ 70 , 20 , 73 , 27 , 80 , 30 , 73 , 33 , 75 , 40 , 70 , 35 , 65 , 40 , 67 , 33 , 60 , 30 , 67 , 27 ]) oled . poly ( 0 , 0 , my_array , ON , NO_FILL ) # filled hexagon star my_array = array ( 'B' , [ 85 , 20 , 90 , 25 , 95 , 20 , 95 , 25 , 100 , 30 , 95 , 35 , 95 , 40 , 90 , 35 , 85 , 40 , 85 , 35 , 80 , 30 , 85 , 25 ]) oled . poly ( 0 , 0 , my_array , ON , FILL ) # outlined hexagon star my_array = array ( 'B' , [ 105 , 20 , 110 , 25 , 115 , 20 , 115 , 25 , 120 , 30 , 115 , 35 , 115 , 40 , 110 , 35 , 105 , 40 , 105 , 35 , 100 , 30 , 105 , 25 ]) oled . poly ( 0 , 0 , my_array , ON , NO_FILL ) # filled rocket my_array = array ( 'B' , [ 0 , 45 , 5 , 50 , 20 , 50 , 20 , 45 , 25 , 53 , 20 , 60 , 20 , 55 , 5 , 55 , 0 , 60 ]) oled . poly ( 0 , 0 , my_array , ON , FILL ) # solid rocket my_array = array ( 'B' , [ 30 , 45 , 35 , 50 , 50 , 50 , 50 , 45 , 55 , 52 , 55 , 54 , 50 , 60 , 50 , 55 , 35 , 55 , 30 , 60 ]) oled . poly ( 0 , 0 , my_array , ON , NO_FILL ) # house outline my_array = array ( 'B' , [ 80 , 40 , 89 , 49 , 89 , 60 , 70 , 60 , 70 , 50 ]) oled . poly ( 0 , 0 , my_array , ON , NO_FILL ) # house fill my_array = array ( 'B' , [ 101 , 40 , 111 , 50 , 111 , 60 , 91 , 60 , 91 , 50 ]) oled . poly ( 0 , 0 , my_array , ON , FILL ) oled . show () Challenge Create a drawing with a rocket flying over a house Add your own shapes When would you use rect() and ellipse() instead of poly? Modify the triangle drawing to move the points with an animation. Use an array of directions that reverse when the points reach the edge of the screen. solution","title":"Sample Polygons"},{"location":"lessons/polygon/#references","text":"MicroPython Framebuf Documentation MicroPython Array","title":"References"},{"location":"lessons/screen-coordinates/","text":"Screen Coordinates In these labs, our robot faces will use a low-cost OLED screen that is 128 pixels wide and 64 pixels high. This screen is big enough to draw faces but small enough to be drawn quickly by our microcontrollers. The grid layout places the origin (0,0) in the upper-left corner of the screen. The horizontal direction is always given first as the distance from the left edge to the point. This is called the X direction. The distance from the top edges of the screen to any point is called the Y direction. Note Our graphics drawing uses the opposite vertical origin to the coordinate system taught in many math classes where the origin is in the lower-left corner of the grid. In the figure above, note that the point in the upper right is (127,0)","title":"Screen Coordinates"},{"location":"lessons/screen-coordinates/#screen-coordinates","text":"In these labs, our robot faces will use a low-cost OLED screen that is 128 pixels wide and 64 pixels high. This screen is big enough to draw faces but small enough to be drawn quickly by our microcontrollers. The grid layout places the origin (0,0) in the upper-left corner of the screen. The horizontal direction is always given first as the distance from the left edge to the point. This is called the X direction. The distance from the top edges of the screen to any point is called the Y direction. Note Our graphics drawing uses the opposite vertical origin to the coordinate system taught in many math classes where the origin is in the lower-left corner of the grid. In the figure above, note that the point in the upper right is (127,0)","title":"Screen Coordinates"}]}