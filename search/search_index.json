{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Robot Faces","text":"<p>This guide will help you learn how to draw fun faces on your robots.  We use bright 128x64 OLED displays that cost about $20.  We use simple MicroPython code so students can create their own personalized robot faces.</p>"},{"location":"about/","title":"About The Robot Faces Book","text":"<p>The book is designed to be a fun way to teach concepts in computational thinking by teaching students how to draw faces on a low-cost OLED display. It was designed to use low-cost parts to keep robot kits as low as possible. Most classrooms can create projects for under $35 per robot if you purchase parts in a quantity of 10.</p>"},{"location":"about/#primary-goals","title":"Primary Goals","text":"<ol> <li>Create hands-on lessons that are fun for students</li> <li>Teach fundamentals of computational thinking such as abstractions, functions and modularity</li> <li>Decompose a complex face into parts (eyes, eyebrows, mouth) with parameters</li> <li>Get students to think about how faces are used to communicate emotions</li> </ol> <p>Sample faces from the Miko Social Robot</p> <p></p>"},{"location":"contact/","title":"Contact","text":"<p>Dan McCreary</p>"},{"location":"getting-started/","title":"Getting Started with Robot Faces","text":"<p>Here are the steps you can use to get started drawing your own robot faces.</p>"},{"location":"getting-started/#step-1-getting-hardware","title":"Step 1: Getting Hardware","text":"<p>You can order the parts online or work with one of our programs that supply parts for classrooms. The minimal drawing kit contains:</p> <ol> <li>A Raspberry Pi Pico</li> <li>A mini solderless [Breadboard]../docs/parts-lists/#solderless-breadboard)</li> <li>An OLED display</li> <li>M-F jumper wires</li> </ol>"},{"location":"getting-started/#step-2-installing-software","title":"Step 2: Installing Software","text":"<p>We use the \"Thonny\" editor to program our faces.  To use it you will need to:</p> <ol> <li>Download and install Thonny</li> <li>Initialize the runtime by using the Thonny Tools -&gt; Options -&gt; Interpreter and select the Raspberry Pi Pico option</li> <li>Press the Install Runtime button</li> <li>Press the Stop/Reset and you should see the prompt:</li> </ol> <pre><code>&gt;&gt;&gt; \n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nMicroPython v1.19.1-854-g35524a6fd on 2023-02-07; Raspberry Pi Pico with RP2040\nType \"help()\" for more information.\n&gt;&gt;&gt; \n</code></pre>"},{"location":"getting-started/#drawing-your-fist-face","title":"Drawing Your Fist Face","text":"<p>You can now copy our \"simple-face.py\" program into your microcontroller into your Thonny program and press the green \"Run\" button.  You will see the following on your display:</p> <p></p>"},{"location":"glossary/","title":"Robot Faces Glossary of Terms","text":""},{"location":"glossary/#blit","title":"Blit","text":"<p>Block transfer</p>"},{"location":"glossary/#ellipse","title":"Ellipse","text":""},{"location":"glossary/#rp2040","title":"RP2040","text":""},{"location":"parts-lists/","title":"Robot Faces Parts List","text":""},{"location":"parts-lists/#microcontrollers","title":"Microcontrollers","text":"<p>You can use any microcontroller that supports an SPI interface and has a MicroPython driver.  Here are some of our favorites.</p>"},{"location":"parts-lists/#raspberry-pi-pico","title":"Raspberry Pi Pico","text":"<p>The Raspberry Pi Pico is a $4 microcontroller that supports SPI.  This allows you to test your face drawing for under $25.</p> <p></p>"},{"location":"parts-lists/#cytron-maker-pi-rp2040","title":"Cytron Maker Pi RP2040","text":""},{"location":"parts-lists/#displays","title":"Displays","text":""},{"location":"parts-lists/#128x64-oleds","title":"128X64 OLEDs","text":"<p>We love the $20 128x64 OLED displays.  These displays have fast SPI drivers that will update the display in around 2 milliseconds.</p>"},{"location":"parts-lists/#robot-chassis","title":"Robot Chassis","text":"<p>We use a standard \"Smart Car\" chassis to drive our cars.  These parts can be purchased for around $5 each in quantity 10.</p>"},{"location":"parts-lists/#sensors","title":"Sensors","text":"<p>This course is not intended to be a complete guide to sensors, but here are a few favorite sensors our students like to use.</p>"},{"location":"parts-lists/#momentary-push-buttons","title":"Momentary Push Buttons","text":"<p>We use momentary push buttons that are ideal for changing the mode of a robot.  They can be purchased for about 10 cents in quantity 10.</p>"},{"location":"parts-lists/#potentiometers","title":"Potentiometers","text":"<p>These are ideal for allowing students to vary a parameter of a face such as the curvature or width of a smile.</p>"},{"location":"parts-lists/#rotary-encoders","title":"Rotary Encoders","text":""},{"location":"parts-lists/#solderless-breadboard","title":"Solderless Breadboard","text":"<p>We use $2 solderless mini breadboards to test our displays.</p> <p>~</p>"},{"location":"references/","title":"References","text":"<ol> <li>Emotive Response to a Hybrid-Face Robot and Translation to Consumer Social Robots Maitreyee Wairagkar et. el., 2020</li> <li>C. L. Breazeal, Designing sociable robots (Intelligent robots and autonomous agents). Cambridge, Mass.: MIT Press, 2002, pp. xviii, 263 p.</li> <li>The role of emotions in the consumer meaning-making of interactions with social robots</li> <li>Paul Ekman's Family Guide to the Pixar Movie Inside Out</li> </ol>"},{"location":"lessons/","title":"List of Lessons","text":""},{"location":"lessons/basic-face-layouts/","title":"Basic Face Layouts","text":""},{"location":"lessons/basic-face-layouts/#drawing-constants","title":"Drawing Constants","text":"<pre><code>HALF_WIDTH = int(WIDTH / 2)\nQUARTER_WIDTH = int(WIDTH / 4)\nHALF_HEIGHT = int(HEIGHT / 2)\nQUARTER_HEIGHT = int(HEIGHT / 4)\n\nWHITE = 1 # 1 is for pixel on\nBLACK = 0 # 0 is for pixel off\n\nNO_FILL = 0 # 0 is for only drawing the outline\nFILL = 1 # 1 for filling all the pixels in an ellipse\n\nBOTTOM_HALF = 12 # this is for drawing the lower half of an ellipse\n</code></pre>"},{"location":"lessons/basic-face-layouts/#the-face-outline","title":"The Face Outline","text":"<p>Let's start out by drawing an outline of the face as a wide white ellipse on a black background. You don't really need to do this part because people can assume the entire screen is the face. We are mostly doing it to get you familiar with drawing with the ellispe() function.</p>"},{"location":"lessons/basic-face-layouts/#if-our-screen-is-128-pixels-wide-make-the-face-be-100-wide","title":"if our screen is 128 pixels wide, make the face be 100 wide","text":"<p>FACE_WIDTH = 100 # 50 over for the left and 50 to the right</p>"},{"location":"lessons/basic-face-layouts/#if-our-screen-is-64-pixels-high-make-our-face-be-60-high","title":"if our screen is 64 pixels high, make our face be 60 high","text":"<p>FACE_HEIGHT = 60 # 20 up and 20 down</p> <p>Remember that the six main parameters of the ellipse function are:</p> <pre><code>display.ellipse(x, y, width, hight, color, fill)\n</code></pre> <p>Here is a sample face outline:</p> <pre><code>oled.ellipse(HALF_WIDTH, HALF_HEIGHT, int(FACE_WIDTH/2), int(FACE_HEIGHT/2), WHITE, FILL)\n</code></pre> <p>Here are the parameters in detail:</p> <ol> <li>Center of Face - the x,y of the ellipse are HALF_WIDTH, HALF_HEIGHT so it is drawn in the center of the display</li> <li>Width and Height of the Face - this is the interger values of half the FACE_WIDTH and half the FACE_HEIGHT</li> <li>Draw with White - this is the WHITE parameter</li> <li>Fill not Outline - this is the FILL parameter</li> </ol>"},{"location":"lessons/basic-face-layouts/#eyes","title":"Eyes","text":"<p>Our eyes can start out by just being two circles.  They need to be drawn about 1/3 to 1/2 of the way down the face.  This is called the \"eye height\" and is measured from the top of the display.</p> <pre><code>EYE_SIZE = 10\n# eyes - black on a white face\n# eye on the left side of the display\noled.ellipse(QUARTER_WIDTH+10, QUARTER_HEIGHT+10, EYE_SIZE, EYE_SIZE, BLACK, FILL)\n# eye on the right side of the display\noled.ellipse(QUARTER_WIDTH*3-10, QUARTER_HEIGHT+10, EYE_SIZE, EYE_SIZE, BLACK, FILL)\n</code></pre> <p>Note that here, when I draw the eyes at 1/4 and 3/4 of the width, they seemed too far apart.  So I added 10 to the left eye and subtracted 10 from the right eye.</p> <p>I also didn't quite like the eyes at 1/4 of the height so I add 10 to each of the eyes distance from the top.</p>"},{"location":"lessons/basic-face-layouts/#mouth","title":"Mouth","text":"<p>To draw a black mouth on a white face we will use the ellipse drawing option to only draw the bottom half of the ellipse.  To do this we just add one more parameter which has a value of 12.</p> <pre><code>oled.ellipse(HALF_WIDTH, HALF_HEIGHT+10, 30, 10, BLACK, FILL, BOTTOM_HALF)\n</code></pre> <p>In this case, I moved the vertical distance down 10 from the center of the display. I made the mouth be 60 pixels wided (twice the horizontal radius of 30), and I made the height of the mouth be 20 (twice the vertical radius).</p>"},{"location":"lessons/basic-face-layouts/#full-face-function","title":"Full Face Function","text":"<p>Here is a full Python function that draws all four components of a face on your robot:</p> <pre><code>def draw_face():\n    # clear the display to make all pixels black\n    oled.fill(0)\n\n    # draw the face outline\n    oled.ellipse(HALF_WIDTH, HALF_HEIGHT, FACE_WIDTH, FACE_HEIGHT, WHITE, FILL)\n\n    # eyes - black ellipses on a white face\n    oled.ellipse(QUARTER_WIDTH+10, QUARTER_HEIGHT+10, EYE_SIZE, EYE_SIZE, BLACK, FILL)\n    oled.ellipse(QUARTER_WIDTH*3-10, QUARTER_HEIGHT+10, EYE_SIZE, EYE_SIZE, BLACK, FILL)\n\n    # mouth - black on a white face\n    oled.ellipse(HALF_WIDTH, HALF_HEIGHT+10, 30, 10, BLACK, FILL, BOTTOM_HALF)\n    oled.show()\n</code></pre> <p>Try to adjust the parameters as you see fit.  See how they change the layout.</p>"},{"location":"lessons/basic-face-layouts/#eyebrows","title":"Eyebrows","text":"<p>Drawing eyebrows are a little more complicated since they can't easily be drawn by simple shapes like a rectangle, circle or ellipse.  But they are very important for signaling different emotions like surprise or anger.</p> <p>As an exercise, do a web search for faces with different emotions and note the shape of the eyebrows.</p>"},{"location":"lessons/basic-face-layouts/#using-the-polygon-functiont-to-draw-eyebrows","title":"Using the Polygon Functiont to draw eyebrows.","text":"<p>To draw a decent eyebrow we will use the powerful and slightly more complicated polygon function.  Firs</p>"},{"location":"lessons/drawing-commands/","title":"Drawing Commands","text":"<p>All of our drawing commands come from the MicroPython FrameBuf drawing primitives.  These are simple drawing operations that are designed to work on microcontrollers with limited memory.</p> <p>Because these commands are all functions associated with the framebuffer class, they are called methods in the documentation.</p> <p>A typical drawing sequence has the following steps:</p> <pre><code># clear the entire display\ndisplay.fill(0)\n# Draw white (1) text starting at x=0 and y = 10 \ndisplay.text('Hello World!', 0, 10, 1)\n# draw a horizontal like starting at x=0 and y=20 that is 128 pixels long\ndisplay.hline(0, 20, 128, 1)\n# this triggers the copy of the entire frame buffer in memory to the display\ndisplay.show()\n</code></pre>"},{"location":"lessons/drawing-commands/#preamble-for-drawing","title":"Preamble for Drawing","text":"<p>All our programs will have approximately the same preamble or setup that appears before our drawing.  Here is a sample of this preamble:</p> <pre><code>from machine import Pin\nimport ssd1306\n\nWIDTH = 128\nHEIGHT = 64\n\nclock=Pin(2) #SCL\ndata=Pin(3) #SDA\nRES = machine.Pin(4)\nDC = machine.Pin(5)\nCS = machine.Pin(6)\n\nspi=machine.SPI(0, sck=clock, mosi=data)\ndisplay = ssd1306.SSD1306_SPI(WIDTH, HEIGHT, spi, DC, RES, CS)\n</code></pre> <p>You may have to modify the pin numbers if you are not using our standard layout.</p>"},{"location":"lessons/drawing-commands/#fill","title":"Fill","text":"<p><code>display.fill(color)</code></p> <p>A color of 0 will be a blank screen.  A fill of 1 will be a white screen. We typically erase an old screen at the top of an animation loop with <code>fill(0)</code></p>"},{"location":"lessons/drawing-commands/#rectangles","title":"Rectangles","text":"<p><code>rect(x, y, width, color)</code></p>"},{"location":"lessons/drawing-commands/#lines","title":"Lines","text":""},{"location":"lessons/drawing-commands/#horizontal-line","title":"Horizontal Line","text":"<p>Draw a horizontal line starting a the point (x,y) of width pixels.</p> <p><code>display.hline(x, y, width, color)</code></p>"},{"location":"lessons/drawing-commands/#vertical-line","title":"Vertical Line","text":"<p>Draw a vertical line starting a the point (x,y) of height pixels.</p> <p><code>display.vline(x, y, height, color)</code></p>"},{"location":"lessons/drawing-commands/#general-line","title":"General Line","text":"<p>Draw a line from a set of coordinates using the given color and a thickness of 1 pixel.  The line method draws the line up to a second set of coordinates</p> <p><code>display.line(x1, y1, x2, y2, color)</code></p>"},{"location":"lessons/drawing-commands/#rectangle","title":"Rectangle","text":"<p><code>rect(x, y, w, h, c[, f])</code></p>"},{"location":"lessons/drawing-commands/#circles-and-ellipse","title":"Circles and Ellipse","text":"<p><code>display.ellipse(x, y, HORZ_RADIUS, VERT_RADIUS, COLOR, FILL_FLAG, QUAD_CODE)</code></p> <p>There is a detailed lesson here</p>"},{"location":"lessons/drawing-commands/#polygons","title":"Polygons","text":"<pre><code>## draw a filled in triangle\nmy_array = array('B', [10,0, 20,10, 0,10])\noled.poly(0,0, my_array, ON, FILL)\n</code></pre> <p>There is a detailed lesson here</p>"},{"location":"lessons/drawing-commands/#scroll","title":"Scroll","text":"<p><code>display.scroll(xstep, ystep)</code></p> <p>Shift the contents of the FrameBuffer by the given vector. This may leave a footprint of the previous colors in the FrameBuffer.</p>"},{"location":"lessons/drawing-commands/#blit","title":"BLIT","text":"<p><code>blit(fbuf, x, y, key=- 1, palette=None)</code></p> <p>Draw another FrameBuffer on top of the current one at the given coordinates. If key is specified then it should be a color integer and the corresponding color will be considered transparent: all pixels with that color value will not be drawn. (If the palette is specified then the key is compared to the value from palette, not to the value directly from fbuf.)</p> <p>The palette argument enables blitting between FrameBuffers with differing formats. Typical usage is to render a monochrome or grayscale glyph/icon to a color display. The palette is a FrameBuffer instance whose format is that of the current FrameBuffer. The palette height is one pixel and its pixel width is the number of colors in the source FrameBuffer. The palette for an N-bit source needs 2**N pixels; the palette for a monochrome source would have 2 pixels representing background and foreground colors. The application assigns a color to each pixel in the palette. The color of the current pixel will be that of that palette pixel whose x position is the color of the corresponding source pixel.</p>"},{"location":"lessons/ellipse/","title":"Drawing Ellipses","text":"<p>Since version 1.19.1-724 of the MicroPython runtime was released in February 2023 we have support for the framebuf Ellipse function.  This function allows us to draw circles and ellipses that are both filled and un-filled.</p> <p>We can also draw into one or more quadrants so we can do 1/4, 1/2, or 3/4 filled ellipses.</p>"},{"location":"lessons/ellipse/#sample-program-code","title":"Sample Program Code","text":"<pre><code># Test of the micropython ellipse function\n# display.ellipse(x, y, HORZ_RADIUS, VERT_RADIUS, COLOR, FILL_FLAG, QUAD_CODE)\n\nfrom machine import Pin\nfrom utime import sleep\nimport framebuf\nimport ssd1306\n\nWIDTH = 128\nHEIGHT = 64\n\nclock=Pin(2) #SCL\ndata=Pin(3) #SDA\nRES = machine.Pin(4)\nDC = machine.Pin(5)\nCS = machine.Pin(6)\n\nspi=machine.SPI(0, sck=clock, mosi=data)\noled = ssd1306.SSD1306_SPI(WIDTH, HEIGHT, spi, DC, RES, CS)\n\n# center the ellipse in the middle of the display\nx = int(WIDTH / 2)\ny = int(HEIGHT / 2)\n\nHORZ_RADIUS = 30 # 30 over for the left and 30 to the right \nVERT_RADIUS = 20 # 20 up and 20 down\nCOLOR = 1 # 0 or 1\n\n# draw an ellipse wihout the fill\noled.ellipse(x, y, HORZ_RADIUS, VERT_RADIUS, COLOR)\noled.show()\n</code></pre>"},{"location":"lessons/ellipse/#ellipse-parameters","title":"Ellipse Parameters","text":"<p><code>display.ellipse(x, y, HORZ_RADIUS, VERT_RADIUS, COLOR, FILL_FLAG, QUAD_CODE)</code></p> <p>Draw an ellipse at the given location. Radii <code>HORZ_RADIUS</code> and <code>VERT_RADIUS</code> define the geometry.</p> <p>If <code>HORZ_RADIUS</code> equal the <code>VERT_RADIUS</code> a circle is drawn. The <code>COLOR</code> parameter defines the color.  0 for OFF and 1 for ON.</p> <p>The optional <code>FILL_FLAG</code> parameter can be set to True to fill the ellipse. Otherwise, just a single pixel outline is drawn.</p>"},{"location":"lessons/ellipse/#quadrant-fill-codes","title":"Quadrant Fill Codes","text":"<p>The optional <code>QUAD_CODE</code> parameter enables drawing to be restricted to certain quadrants of the ellipse.</p> <p>You can add the following numbers to figure out the quadrant code:</p> <ul> <li>1 - upper right</li> <li>2 - upper left</li> <li>4 - lower left</li> <li>8 - lower right</li> </ul> <p>For example for the lower half of the ellipse on you add 4 + 8 = 12.</p> <p>Here is a complete list of the 16 possible values of the code:</p> Code Description 0 all off 1 upper right on 2 upper left on 3 top half on 4 lower left on 5 lower left and upper right on 6 left side on 7 lower right off 9 right side on 10 upper left and lower right are on 11 all but lower left are on 12 lower half on 13 all but upper left are on 14 all but upper right are on 15 all four quadrants are drawn"},{"location":"lessons/ellipse/#references","title":"References","text":"<p>MicroPython Framebuf Documentation</p>"},{"location":"lessons/emotion-types/","title":"Emotion Types","text":"<p>This project puts a focus on using MicroPython and OLED displays to generate about seven primary emotions.</p> <p>Here are the seven faces that Paul Ekman describes in his research:</p> <ol> <li>happy</li> <li>sad</li> <li>angry</li> <li>afraid</li> <li>surprise</li> <li>disgust</li> <li>contempt</li> </ol> <p>The feeling of tied or sleepy can also be shown on a robots face.</p> <p>Here are photos of these seven emotions on people:</p> <p></p>"},{"location":"lessons/emotion-types/#inside-out-emotions","title":"Inside Out Emotions","text":"<p>The Pixar movie Inside Out focused on only five emotions in its characters:</p> <ol> <li>Joy</li> <li>Sadness</li> <li>Fear</li> <li>Disgust</li> <li>Anger</li> </ol> <p>Some of these emotions are easy for people to recognize.  Here is this list sorted by confidence take from a table in Emotive Response to a Hybrid-Face Robot and Translation to Consumer Social Robots:</p> <p>OVERALL EMOTION RECOGNITION ACCURACIES</p> <ol> <li>Sad: 88%</li> <li>Happy: 84.8</li> <li>Surprise: 79.6</li> <li>Tired: 69.0</li> <li>Angry: 68.5</li> <li>Disgust: 63.8</li> <li>Stern: 59.2</li> </ol> <p>Note that the emotion of contempt was not scored in this paper.</p>"},{"location":"lessons/emotion-types/#references","title":"References","text":"<ol> <li>Ekman and Friesen</li> </ol>"},{"location":"lessons/eye-scanner/","title":"Eye Scanner","text":"<pre><code>from machine import Pin\nfrom utime import sleep, ticks_us\nfrom math import sqrt\nimport framebuf\nimport ssd1306\n\nWIDTH = 128\n# bit shifting only works when the numbers are a power of 2\nHALF_WIDTH = WIDTH &gt;&gt; 1\nQUARTER_WIDTH = HALF_WIDTH &gt;&gt; 1\n\nHEIGHT = 64\nHALF_HEIGHT = HEIGHT &gt;&gt; 1\nQUARTER_HEIGHT = HALF_HEIGHT &gt;&gt; 1\nONE_THIRD_HEIGHT = int(HEIGHT/3)\n\n# draw readability\nON = 1\nOFF = 0\nNO_FILL = 0\nFILL = 1\n\nclock=Pin(2) #SCL\ndata=Pin(3) #SDA\nRES = machine.Pin(4)\nDC = machine.Pin(5)\nCS = machine.Pin(6)\n\nspi=machine.SPI(0, sck=clock, mosi=data)\noled = ssd1306.SSD1306_SPI(WIDTH, HEIGHT, spi, DC, RES, CS)\n\nphm = 18 # pupal horizontal movement range \neye_dist_from_top = 21\neyeWidth = 27\neyeHeight = 10\nmouth_vpos = 45\nmouth_width = 40\n\ndef draw_face(eye_direction):\n    oled.fill(0)\n\n    # left eye\n    oled.ellipse(32, eye_dist_from_top, eyeWidth, eyeHeight, ON, FILL)\n    oled.ellipse(32+i, eye_dist_from_top, 5, 5, OFF, FILL)\n\n    # right eye\n    oled.ellipse(94, eye_dist_from_top, eyeWidth, eyeHeight, ON, FILL)\n    oled.ellipse(94+i, eye_dist_from_top, 5, 5, OFF, FILL)\n\n    # draw mouth\n    # draw bottom half by doing a bitwise and of 8 and 4\n    oled.ellipse(HALF_WIDTH, mouth_vpos, mouth_width, 10, ON, NO_FILL, 12)\n\n    oled.show()\n\ndelay = .02\nwhile True:\n    for i in range(-phm, phm):\n        draw_face(i)\n        sleep(delay)\n    for i in range(phm, -phm, -1):\n        draw_face(i)\n        sleep(delay)\n</code></pre>"},{"location":"lessons/eyebrows/","title":"Adding Eyebrows to a Face","text":"<p>In this lesson, we will add eyebrows to our basic face layout.  We will use the framebuf poly that is available in 1.19 and higher</p> <p></p> <pre><code>'''\nTest of the MicroPython framebuf poly drawing function\n\n    from array import array\n\n    my_array = array('h', [60,10, 50,60, 40,30])\n    display.poly(0,0, my_array, ON, FILL)\n\n'''\n\nfrom machine import Pin\nfrom utime import sleep, ticks_us\nfrom array import array\nimport framebuf\nimport ssd1306\n\nWIDTH = 128\n# bit shifting only works when the numbers are a power of 2\nHALF_WIDTH = WIDTH &gt;&gt; 1\nQUARTER_WIDTH = HALF_WIDTH &gt;&gt; 1\nHEIGHT = 64\nHALF_HEIGHT = HEIGHT &gt;&gt; 1\nQUARTER_HEIGHT = HALF_HEIGHT &gt;&gt; 1\nONE_THIRD_HEIGHT = int(HEIGHT/3)\n\n# draw readability\nON = 1\nOFF = 0\nNO_FILL = 0\nFILL = 1\n\nclock=Pin(2) #SCL\ndata=Pin(3) #SDA\nRES = machine.Pin(4)\nDC = machine.Pin(5)\nCS = machine.Pin(6)\n\nspi=machine.SPI(0, sck=clock, mosi=data)\noled = ssd1306.SSD1306_SPI(WIDTH, HEIGHT, spi, DC, RES, CS)\n\n\n# copy onto display\n\nbottom_row_text_vpos = 57\n\ndef draw_face_grid():\n    oled.vline(QUARTER_WIDTH, 0, HEIGHT, 1) # x, y, len, color\n    oled.vline(QUARTER_WIDTH*3, 0, HEIGHT, 1)\n    oled.hline(0, ONE_THIRD_HEIGHT, WIDTH, 1)\n\nphm = 18 # puple horizontal movement\neye_dist_from_top = 25\neyeWidth = 27\neyeWidth_half = int(eyeWidth/2)\neyeHeight = 7\nmouth_vpos = 40\nmouth_width = 40\npupil_width = 5\n\nleft_eyebrow  = array('h', [-eyeWidth_half,-1,      15,-5, eyeWidth_half+10,1,  15,-2])\nright_eyebrow = array('h', [-eyeWidth_half-10, 1,  -15,-5, eyeWidth_half,0,    -15,-2])\n\ndef draw_eye(x):\n    oled.ellipse(x, eye_dist_from_top, eyeWidth, eyeHeight, ON, FILL)\n    # draw a black pupil on the white eye\n    oled.ellipse(x, eye_dist_from_top, pupil_width, pupil_width, OFF, FILL)\n\n\ndef draw_face(eye_direction):\n\n    # draw_face_grid()\n    start = ticks_us()\n    # left eye\n    draw_eye(QUARTER_WIDTH)\n\n    # eyebrow\n    oled.poly(QUARTER_WIDTH,eye_dist_from_top-10, left_eyebrow, ON, FILL)\n\n    # right eye\n    draw_eye(QUARTER_WIDTH*3)\n    oled.poly(QUARTER_WIDTH*3,eye_dist_from_top-10, right_eyebrow, ON, FILL)\n\n    # draw mouth\n    # draw bottom half by doing a bitwise and of 8 and 4\n    oled.ellipse(HALF_WIDTH, mouth_vpos, mouth_width, 10, ON, NO_FILL, 12)\n    end = ticks_us()\n    drawTime = end - start\n    # oled.text(str(drawTime), 0, bottom_row_text_vpos)\n    oled.show()\n\n# outline box\n\noled.fill(0)\noled.rect(0,0, WIDTH, HEIGHT, 1)\ndraw_face(0)\n</code></pre>"},{"location":"lessons/interactions/","title":"Interactions","text":""},{"location":"lessons/interactions/#eye-pupil-movement","title":"Eye Pupil Movement","text":""},{"location":"lessons/interactions/#blinking","title":"Blinking","text":""},{"location":"lessons/multiple-threads/","title":"Multiple Threads","text":"<p>Microcontrollers have more than one core.  We can delegate face updates to a second core.</p>"},{"location":"lessons/polygon/","title":"Drawing Polygons","text":""},{"location":"lessons/polygon/#lesson-overview","title":"Lesson Overview","text":"<p>In this a lesson about how to use the <code>poly()</code> function to do drawing on with MicroPython.  The <code>poly()</code> function is implemented as part of the Framebuf function in MicroPython.  This means that it will run on any display that uses frame buffers.  We think you will find <code>poly()</code> a very powerful and flexibile way to draw features on a face such as a nose or eyebrows.</p>"},{"location":"lessons/polygon/#drawing-with-the-polygon-function","title":"Drawing with the Polygon Function","text":"<p>Since v1.19.1-724 MicroPython includes a flexible way to draw any polygon of any number of points either in outline or filled mode.  With this function, you can quickly draw complex shapes such as triangles, hexagons, stars, rockets or houses.</p> <p>To use the <code>poly()</code> function we must pass it an array of points.  The syntax for short array initialization is as follows:</p> <pre><code>my_array = array('B', [30,10, 100,20, 50,60])\n</code></pre> <p>The letter \"B\" signals that each element will be an unsigned byte which is enough for our purposes.  Many systems use an \"h\" which is a signed two-byte value which can be any integer in a range from -32,768 to 32,767.  Since our OLED screen is only a maximum of 128 the B is the most compact value, but remember that the max value is 255 and we can't store negative values in an unsigned byte.</p> <pre><code>from machine import Pin\nfrom array import array\nimport ssd1306\n\nclock=Pin(2) #SCL\ndata=Pin(3) #SDA\nRES = machine.Pin(4)\nDC = machine.Pin(5)\nCS = machine.Pin(6)\n\nspi=machine.SPI(0, sck=clock, mosi=data)\noled = ssd1306.SSD1306_SPI(128, 64, spi, DC, RES, CS)\n\noled.fill(0)\n# draw three points in a triangle to be filled using signed two-byte integers (h)\nmy_array = array('B', [30,10, 100,20, 50,60])\n# at poing (0,0) draw a polygon with on bits and filled\noled.poly(0,0, my_array, 1, 1)\noled.show()\n</code></pre> <p>This will generate the following image:</p> <p></p>"},{"location":"lessons/polygon/#sample-polygons","title":"Sample Polygons","text":"<p>Here is an example program</p> <pre><code>from machine import Pin\nfrom utime import sleep, ticks_us\nfrom array import array\nimport framebuf\nimport ssd1306\n\nWIDTH = 128\nHEIGHT = 64\n\n# draw readability variables\nON = 1 # white\nOFF = 0 # black\nNO_FILL = 0 # just the border is drawn\nFILL = 1 # all pixels within the polygon are drawn\n\nclock=Pin(2) #SCL\ndata=Pin(3) #SDA\nRES = machine.Pin(4)\nDC = machine.Pin(5)\nCS = machine.Pin(6)\n\nspi=machine.SPI(0, sck=clock, mosi=data)\noled = ssd1306.SSD1306_SPI(WIDTH, HEIGHT, spi, DC, RES, CS)\n\noled.fill(0)\n\n\n# basic filled triangle\nmy_array = array('B', [10,0, 20,10, 0,10])\noled.poly(0,0, my_array, ON, FILL)\n\n# basic outline triangle\nmy_array = array('B', [30,0, 40,10, 20,10])\noled.poly(0,0, my_array, ON, NO_FILL)\n\n\n# basic outline pentagon\nmy_array = array('B', [50,0, 60,10, 55,20, 45,20, 40,10])\noled.poly(0,0, my_array, ON, FILL)\n\nmy_array = array('B', [70,0, 80,10, 75,20, 65,20, 60,10])\noled.poly(0,0, my_array, ON, NO_FILL)\n\n\n# basic outline hexagon\nmy_array = array('B', [85,0, 95,0, 100,10, 95,20, 85,20, 80,10])\noled.poly(0,0, my_array, ON, FILL)\n\nmy_array = array('B', [105,0, 115,0, 120,10, 115,20, 105,20, 100,10])\noled.poly(0,0, my_array, ON, NO_FILL)\n\n\n# octagon\nmy_array = array('B', [05,20, 15,20, 20,25, 20,35, 15,40, 5,40, 0,35, 0,25])\noled.poly(0,0, my_array, ON, FILL)\n\nmy_array = array('B', [25,20, 35,20, 40,25, 40,35, 35,40, 25,40, 20,35, 20,25])\noled.poly(0,0, my_array, ON, NO_FILL)\n\n# filled five point star\nmy_array = array('B', [50,20, 53,27, 60,30, 53,33, 55,40, 50,35, 45,40, 47,33, 40,30, 47,27])\noled.poly(0,0, my_array, ON, FILL)\n\n\n# outlined five point star\nmy_array = array('B', [70,20, 73,27, 80,30, 73,33, 75,40, 70,35, 65,40, 67,33, 60,30, 67,27])\noled.poly(0,0, my_array, ON, NO_FILL)\n\n# filled hexagon star\nmy_array = array('B', [85,20, 90,25, 95,20, 95,25, 100,30, 95,35, 95,40, 90,35, 85,40, 85,35, 80,30, 85,25])\noled.poly(0,0, my_array, ON, FILL)\n\n\n# outlined hexagon star\nmy_array = array('B', [105,20, 110,25, 115,20, 115,25, 120,30, 115,35, 115,40, 110,35, 105,40, 105,35, 100,30, 105,25])\noled.poly(0,0, my_array, ON, NO_FILL)\n\n# filled rocket\nmy_array = array('B', [0,45, 5,50, 20,50, 20,45, 25,53, 20,60, 20,55, 5,55, 0,60])\noled.poly(0,0, my_array, ON, FILL)\n\n# solid rocket\nmy_array = array('B', [30,45, 35,50, 50,50, 50,45, 55,52, 55,54, 50,60, 50,55, 35,55, 30,60])\noled.poly(0,0, my_array, ON, NO_FILL)\n\n\n# house outline\nmy_array = array('B', [80,40, 89,49, 89,60, 70,60, 70,50])\noled.poly(0,0, my_array, ON, NO_FILL)\n\n# house fill\nmy_array = array('B', [101,40, 111,50, 111,60, 91,60, 91,50])\noled.poly(0,0, my_array, ON, FILL)\n\noled.show()\n</code></pre> <p>Challenge</p> <ol> <li>Create a drawing with a rocket flying over a house</li> <li>Add your own shapes</li> <li>When would you use rect() and ellipse() instead of poly?</li> <li>Modify the triangle drawing to move the points with an animation.  Use an array of directions that reverse when the points reach the edge of the screen. solution</li> </ol>"},{"location":"lessons/polygon/#references","title":"References","text":"<p>MicroPython Framebuf Documentation MicroPython Array</p>"},{"location":"lessons/rotary/","title":"Rotary Encoder","text":"<p>https://raw.githubusercontent.com/miketeachman/micropython-rotary/master/Examples/example_simple.py</p> <pre><code># example for MicroPython rotary encoder based on the Mike Teachman driver \n\nimport sys\nfrom machine import Pin\nfrom rotary_irq_rp2 import RotaryIRQ\nimport time\n\nPIN_NUM_CLK = 14\nPIN_NUM_DATA = 15\n\n# defauls are for pull up input pins and bounded ranges\nr = RotaryIRQ(pin_num_clk=PIN_NUM_CLK,\n              pin_num_dt=PIN_NUM_DATA,\n              min_val=0,\n              max_val=20)\n\nval_old = r.value()\n\nwhile True:\n    val_new = r.value()\n\n    if val_old != val_new:\n        val_old = val_new\n        print('result =', val_new)\n\n    time.sleep_ms(50)\n</code></pre> <p>We modified the driver in /lib/rotary.py to start half-way between the min and the max:</p> <pre><code>def __init__(self, min_val, max_val, incr, reverse, range_mode, half_step, invert):\n        self._min_val = min_val\n        self._max_val = max_val\n        self._incr = incr\n        self._reverse = -1 if reverse else 1\n        self._range_mode = range_mode\n        # change by DGM to make the default value 1/2 the min/max\n        self._value = int((max_val - min_val)/2)\n        self._state = _R_START\n        self._half_step = half_step\n        self._invert = invert\n        self._listener = []\n</code></pre> <p>We also modified the default values in /libto reflect our hardware:</p> <p>```python</p>"},{"location":"lessons/rotary/#here-are-all-the-default-values-change-as-appropriate","title":"here are all the default values - change as appropriate","text":"<p>class RotaryIRQ(Rotary):     def init(         self,         pin_num_clk,         pin_num_dt,         min_val=-10,         max_val=10,         incr=1,         reverse=False,         range_mode=Rotary.RANGE_BOUNDED,         pull_up=True,         half_step=False,         invert=False     ):         super().__init```</p>"},{"location":"lessons/screen-coordinates/","title":"Screen Coordinates","text":"<p>In these labs, our robot faces will use a low-cost OLED screen that is 128 pixels wide and 64 pixels high.  This screen is big enough to draw faces but small enough to be drawn quickly by our microcontrollers.</p> <p>The grid layout places the origin <code>(0,0)</code> in the upper-left corner of the screen. The horizontal direction is always given first as the distance from the left edge to the point.  This is called the X direction.</p> <p>The distance from the top edges of the screen to any point is called the Y direction.</p> <p>Note</p> <p>Our graphics drawing uses the opposite vertical origin to the coordinate system taught in many math classes where the origin is in the lower-left corner of the grid.</p> <p>In the figure above, note that the point in the upper right is (127,0)</p>"}]}